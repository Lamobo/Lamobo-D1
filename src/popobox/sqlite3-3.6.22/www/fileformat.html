<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<title>SQLite Database File Format</title>
<style type="text/css">
body {
    margin: auto;
    font-family: Verdana, sans-serif;
    padding: 8px 1%;
}

a { color: #45735f }
a:visited { color: #734559 }

.logo { position:absolute; margin:3px; }
.tagline {
  float:right;
  text-align:right;
  font-style:italic;
  width:300px;
  margin:12px;
  margin-top:58px;
}

.toolbar {
  font-variant: small-caps;
  text-align: center;
  line-height: 1.6em;
  margin: 0;
  padding:1px 8px;
}
.toolbar a { color: white; text-decoration: none; padding: 6px 12px; }
.toolbar a:visited { color: white; }
.toolbar a:hover { color: #80a796; background: white; }

.content    { margin: 5%; }
.content dt { font-weight:bold; }
.content dd { margin-bottom: 25px; margin-left:20%; }
.content ul { padding:0px; padding-left: 15px; margin:0px; }

/* rounded corners */
.se  { background: url(images/se.png) 100% 100% no-repeat #80a796}
.sw  { background: url(images/sw.png) 0% 100% no-repeat }
.ne  { background: url(images/ne.png) 100% 0% no-repeat }
.nw  { background: url(images/nw.png) 0% 0% no-repeat }

/* Things for "fancyformat" documents start here. */
.fancy .codeblock i { color: darkblue; }
.fancy h1,.fancy h2,.fancy h3,.fancy h4 {font-weight:normal;color:#80a796}
.fancy h2 { margin-left: 10px }
.fancy h3 { margin-left: 20px }
.fancy h4 { margin-left: 30px }
.fancy th {white-space:nowrap;text-align:left;border-bottom:solid 1px #444}
.fancy th, .fancy td {padding: 0.2em 1ex; vertical-align:top}
.fancy #toc a        { color: darkblue ; text-decoration: none }
.fancy .todo         { color: #AA3333 ; font-style : italic }
.fancy .todo:before  { content: 'TODO:' }
.fancy p.todo        { border: solid #AA3333 1px; padding: 1ex }
.fancy img { display:block; }
.fancy :link:hover, .fancy :visited:hover { background: wheat }
.fancy p,.fancy ul,.fancy ol { margin: 1em 5ex }
.fancy li p { margin: 1em 0 }
/* End of "fancyformat" specific rules. */

</style>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  
</head>
<body>
<div><!-- container div to satisfy validator -->

<a href="index.html">
<img class="logo" src="images/SQLite.gif" alt="SQLite Logo"
 border="0"></a>
<div><!-- IE hack to prevent disappearing logo--></div>
<div class="tagline">Small. Fast. Reliable.<br>Choose any three.</div>

<table width=100% style="clear:both"><tr><td>
  <div class="se"><div class="sw"><div class="ne"><div class="nw">
  <div class="toolbar">
    <a href="about.html">About</a>
    <a href="sitemap.html">Sitemap</a>
    <a href="docs.html">Documentation</a>
    <a href="download.html">Download</a>
    <a href="copyright.html">License</a>
    <a href="news.html">News</a>
    <!-- <a href="dev.html">Developers</a> -->
    <a href="support.html">Support</a>
  </div></div></div></div></div>
</td></tr></table>
  



    <link type="text/css" rel="stylesheet" href="images/fileformat/rtdocs.css">

    <div class=fancy>
    <div style="font-size:2em;text-align:center;color:#80a796">SQLite Database File Format</div>
    <div style="font-size:1.5em;margin:1em;color:#80a796">Table Of Contents</div>
    <div id=toc>
      
    <div style="margin-left:6ex">
    <a href="#section_1">1 Document Overview</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#section_1_1">1.1 Scope and Purpose</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#section_1_2">1.2 Document and Requirements Organization</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#section_1_3">1.3 Glossary</a>
    </a></div>
  
    <div style="margin-left:6ex">
    <a href="#database_file_format">2 Database Image Format Details</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#fileformat_overview">2.1 Image Format Overview</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#section_2_2">2.2 Global Structure</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#database_header">2.2.1 Database Header</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#pages_and_page_types">2.2.2 Pages and Page Types</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#schema_table">2.2.3 The Schema Table</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#btree_structures">2.3 B-Tree Structures</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#varint_format">2.3.1 Variable Length Integer Format</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#record_format">2.3.2 Database Record Format</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#index_btrees">2.3.3 Index B-Trees</a>
    </a></div>
  
    <div style="margin-left:24ex">
    <a href="#section_2_3_3_1">2.3.3.1 Index B-Tree Content</a>
    </a></div>
  
    <div style="margin-left:24ex">
    <a href="#index_btree_compare_func">2.3.3.2 Record Sort Order</a>
    </a></div>
  
    <div style="margin-left:24ex">
    <a href="#index_btree_page_format">2.3.3.3 Index B-Tree Page Format</a>
    </a></div>
  
    <div style="margin-left:24ex">
    <a href="#index_btree_cell_format">2.3.3.4 Index B-Tree Cell Format</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#table_btrees">2.3.4 Table B-Trees</a>
    </a></div>
  
    <div style="margin-left:24ex">
    <a href="#table_btree_content">2.3.4.1 Table B-Tree Content</a>
    </a></div>
  
    <div style="margin-left:24ex">
    <a href="#section_2_3_4_2">2.3.4.2 Table B-Tree Page Format</a>
    </a></div>
  
    <div style="margin-left:24ex">
    <a href="#table_btree_cell_format">2.3.4.3 Table B-Tree Cell Format</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#overflow_page_chains">2.3.5 Overflow Page Chains</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#free_page_list">2.4 The Free Page List</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#pointer_map_pages">2.5 Pointer Map Pages</a>
    </a></div>
  
    <div style="margin-left:6ex">
    <a href="#file_system_usage">3 Database File-System Representation</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#journal_file_formats">3.1 Journal File Formats</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#journal_file_format">3.1.1 Journal File Details</a>
    </a></div>
  
    <div style="margin-left:24ex">
    <a href="#journal_header_format">3.1.1.1 Journal Header Format</a>
    </a></div>
  
    <div style="margin-left:24ex">
    <a href="#journal_record_format">3.1.1.2 Journal Record Format</a>
    </a></div>
  
    <div style="margin-left:24ex">
    <a href="#master_journal_ptr">3.1.1.3 Master Journal Pointer</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#masterjournal_file_format">3.1.2 Master-Journal File Details</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#reading_from_files">3.2 Reading an SQLite Database</a>
    </a></div>
  
    <div style="margin-left:6ex">
    <a href="#interoperability_requirements">4 SQLite Interoperability Requirements</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#writing_database">4.1 Writing to an SQLite Database File</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#rollback_journal_method">4.1.1 The Rollback-Journal Method</a>
    </a></div>
  
    <div style="margin-left:18ex">
    <a href="#atomic_write_method">4.1.2 The Atomic-Write Method</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#locking_protocol">4.2 SQLite Locking Protocol</a>
    </a></div>
  
    <div style="margin-left:12ex">
    <a href="#database_header_cookies_protocol">4.3 SQLite Database Header Cookie Protocol</a>
    </a></div>
  
    <div style="margin-left:6ex">
    <a href="#section_5">5 References</a>
    </a></div>
  
    </div id>
    

<h1 id="section_1">1 Document Overview</h1>


  <h2 id="section_1_1">1.1 Scope and Purpose</h2>


  <p>
    
    This document provides an engineering guide to the file formats used by 
    SQLite to store databases on disk. It also contains a description of the
    file locking protocol used by SQLite to control read and write access to 
    the files and other protocols for safely modifying the database in a live
    system (one that may contain other database clients). It is intended that 
    this document shall provide all the information required to create an 
    system that reads and writes SQLite databases in a way that is completely 
    compatible with SQLite itself. There are two broad purposes for providing 
    this information:

  <ul>
    <li><p> To make it easier to maintain, test and improve the SQLite 
            software library.

    <li><p> To facilitate the development of external (non-SQLite) software that may 
            operate directly on SQLite databases stored within a file-system. For
	    example a database space analysis utility or a competing database
	    client implementation.
  </ul>

  <p>
    The availability of this information makes an SQLite database an even safer
    choice for long-term data storage. If at some point in the future the
    SQLite software library cannot be used to access an SQLite database that
    contains useful data, a procedure or software module may be developed based
    on the content of this document to extract the required data.

  <p>
    None of the information contained in this document is required by programmers
    wishing to use the SQLite library in applications. The intended audience is
    engineers working on SQLite itself or those interested in creating alternative
    methods of accessing SQLite databases (without using SQLite).


  <h2 id="section_1_2">1.2 Document and Requirements Organization</h2>


    <p>
      The content of this document is divided into three sections.

    <p>
      <b>Section <cite><a href="#database_file_format" title="Database Image Format Details">2</a></cite></b> describes the format 
      of a <a class=defnlink href="#glossary_Database_image">database image</a>. A <a class=defnlink href="#glossary_Database_image">database image</a> is the serialized form of an 
      SQLite database that is stored on disk.

    <p>
      Usually, an SQLite <a class=defnlink href="#glossary_Database_image">database image</a> is stored in a single file on disk, 
      an SQLite <a class=defnlink href="#glossary_Database_file">database file</a>. However, while the <a class=defnlink href="#glossary_Database_image">database image</a> as stored 
      on disk is being modified, it may be temporarily stored in a more
      convoluted format, distributed between two files, the <a class=defnlink href="#glossary_Database_file">database file</a>
      and a <a class=defnlink href="#glossary_Journal_file">journal file</a>. If a failure occurs while modifying a <a class=defnlink href="#glossary_Database_image">database image</a>
      in this fashion, then the <a class=defnlink href="#glossary_Database_image">database image</a> must be extracted from the
      database and <a class=defnlink href="#glossary_Journal_file">journal files</a> found in the file-system following recovery
      (other documentation refers to this as "hot journal rollback"). <b>Section 
      <cite><a href="#file_system_usage" title="Database File-System Representation">3</a></cite></b> describes the format used by the
      <a class=defnlink href="#glossary_Journal_file">journal file</a> and the rules for correctly reading a <a class=defnlink href="#glossary_Database_image">database image</a> from
      the combination of a <a class=defnlink href="#glossary_Database_file">database file</a> and <a class=defnlink href="#glossary_Journal_file">journal file</a>. 
      

    <p><b>Section <cite><a href="#interoperability_requirements" title="SQLite Interoperability Requirements">4</a></cite></b> contains 
      descriptions of and software requirements related to other protocols that
      must be observed by software that reads and writes SQLite databases
      within a live system, including:


    <ul>
      <li>requirements governing the integrity of <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representations</a>,
      <li>the locking protocol used by SQLite to manage read and write access
          to the database and <a class=defnlink href="#glossary_Journal_file">journal files</a> within the file-system, and
      <li>the change-counter and schema-cookie protocols that must be followed
          by all database writers to facilitate the implementation of
          efficient in-memory caches of the database schema and content by
          readers and writers.
    </ul>

  <h2 id="section_1_3">1.3 Glossary</h2>

    <table id=glossary>
      <tr><td>Auto-vacuum last root-page<td>
        A page number stored as 32-bit integer at byte offset 52 of the
        <a class=defnlink href="#glossary_Database_header">database header</a> (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>). In
        an auto-vacuum database, this is the numerically largest 
        <i>root-page</i> number in the database. Additionally, all pages that
        occur before this page in the database are either B-Tree <i>root
        pages</i>, <i>pointer-map pages</i> or the <i>locking page</i>.

      <tr><td>Auto-vacuum database      <td>
        Each database is either an auto-vacuum database or a non auto-vacuum
        database. Auto-vacuum databases feature pointer-map pages (section
        <cite><a href="#pointer_map_pages" title="Pointer Map Pages">2.5</a></cite>) and have a non-zero value stored
        as a 4-byte big-endian integer at offset 52 of the <a class=defnlink href="#glossary_Database_header">database header</a> (section
        <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>).
      <tr><td>B-Tree                    <td>
        A B-Tree is a tree structure optimized for offline storage. The table
        and index data in an SQLite <a class=defnlink href="#glossary_Database_file">database file</a> is stored in B-Tree
        structures.

      <tr><td>B-Tree cell               <td>
        Each database page that is part of a B-Tree structure contains zero
        or more B-Tree cells. A B-Tree cell contains a single B-Tree key value
        (either an integer or database record) and optionally an associated
        database record value.

      <tr><td>B-Tree page               <td>
        A database page that is part of a B-Tree tree structure (not an
        overflow page).

      <tr><td>(B-Tree) page header      <td>
        The 8-byte (leaf pages) or 12-byte (internal node pages) header that
        occurs at the start of each B-Tree page.

      <tr><td>Cell content area         <td>
        The area within a B-Tree page in which the B-Tree cells are stored.

      <tr><td>(Database) text encoding  <td>
        The text encoding used for all text values in the <a class=defnlink href="#glossary_Database_file">database file</a>. One
        of UTF-8, big-endian UTF-16 and little-endian UTF-16. The database
        text encoding is defined by a 4 byte field stored at byte offset
        56 of the <a class=defnlink href="#glossary_Database_header">database header</a> (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>).

      <tr><td class=defn><a name="glossary_Database_header"></a><a class=defnlink href="#glossary_Database_header">Database header</a> <td>
        The first 100 bytes of an SQLite <a class=defnlink href="#glossary_Database_image">database image</a> constitute the
	<a class=defnlink href="#glossary_Database_header">database header</a>. See section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite> for details.
      

      <tr><td>(Database) <a class=defnlink href="#glossary_Page_size">page size</a>      <td>
        An SQLite <a class=defnlink href="#glossary_Database_file">database file</a> is divided into one or more pages of
        <a class=defnlink href="#glossary_Page_size">page-size</a> bytes each.

      <tr><td>Database record           <td>
        A database record is a blob of data containing the serialized
        representation of an ordered list of one or more SQL values.

      <tr><td>Database record header    <td>
        The first part of each database record contains the database
        record header. It encodes the types and lengths of values stored
        in the record (see section <cite><a href="#record_format" title="Database Record Format">2.3.2</a></cite>).

      <tr><td>Database record data area <td>
        Following the database record header in each database record is
        the database record data area. It contains the actual data (string
        content, numeric value etc.) of all values in the record 
        (see section <cite><a href="#record_format" title="Database Record Format">2.3.2</a></cite>).

      <tr><td>Default pager cache size  <td>
        A 32-bit integer field stored at byte offset 48 of the <a class=defnlink href="#glossary_Database_file">database file</a>
        header (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>).

      <tr><td style="white-space:nowrap">(Database) usable <a class=defnlink href="#glossary_Page_size">page size</a> <td>
        The number of bytes of each database page that is usable. This
        is the <a class=defnlink href="#glossary_Page_size">page-size</a> less the number of bytes left unused at the end
        of each page. The number of bytes left unused is governed by the
        value stored at offset 20 of the <a class=defnlink href="#glossary_Database_header">database header</a> (see section
        <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>).

      <tr><td>File format read version  <td>
        Single byte field stored at byte offset 20 of the <a class=defnlink href="#glossary_Database_header">database header</a>
        (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>).

      <tr><td>File format write version  <td>
        Single byte field stored at byte offset 19 of the <a class=defnlink href="#glossary_Database_header">database header</a>
        (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>).

      <tr><td>File change counter       <td>
        A 32-bit integer field stored at byte offset 24 of the <a class=defnlink href="#glossary_Database_file">database file</a>
        header (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>). Normally, SQLite
        increments this value each time it commits a transaction.

      <tr><td>Fragment                  <td>
        A block of 3 or less bytes of unused space within the cell content
        area of a B-Tree page.

      <tr><td>Free block                <td>
        A block of 4 or more bytes of unused space within the cell content
        area of a B-Tree page.

      <tr><td>Free block list           <td>
        The linked list of all free blocks on a single B-Tree page (see 
        section <cite><a href="#index_btree_page_format" title="Index B-Tree Page Format">2.3.3.3</a></cite>).

      <tr><td>Free page                 <td>
        A page that is not currently being used to store any database data
        or meta data. Part of the free-page list.

      <tr><td>Free page list            <td>
        A data structure within an SQLite <a class=defnlink href="#glossary_Database_file">database file</a> that links all the
        free-pages together.

      <tr><td>Index B-Tree              <td>
        One of two variants on the B-Tree data structure used within SQLite
        <a class=defnlink href="#glossary_Database_file">database files</a>. An index B-Tree (section <cite><a href="#index_btrees" title="Index B-Trees">2.3.3</a></cite>)
        uses database records as keys.

      <tr><td>Incremental Vacuum flag   <td>
        A 32-bit integer field stored at byte offset 64 of the <a class=defnlink href="#glossary_Database_file">database file</a>
        header (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>). In auto-vacuum 
        databases, if this field is non-zero then the database is not
        automatically compacted at the end of each transaction.

      <tr><td>Locking page              <td>
        The database page that begins at the 1GB (2<sup>30</sup> byte)
        boundary. This page is always left unused.

      <tr><td>Logical database          <td>
        An SQLite <a class=defnlink href="#glossary_Database_file">database file</a> is a serialized representation of a logical
        database. A logical database consists of the SQL database schema,
        the content of the various tables in the database, and assorted
        database properties that may be set by the user (auto-vacuum,
        <a class=defnlink href="#glossary_Page_size">page-size</a>, user-cookie value etc.),

      <tr><td>Non-auto-vacuum database  <td>
        Any database that is not an auto-vacuum database. A non-auto-vacuum
        database contains no pointer-map pages and has a zero value stored
        in the 4-byte big-endian integer field at offset 52 of the database
        <a class=defnlink href="#glossary_Database_header">database header</a> (section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>).

      <tr><td>Overflow chain             <td>
        A linked list of overflow pages across which a single (large)
        database record is stored (see section 
        <cite><a href="#overflow_page_chains" title="Overflow Page Chains">2.3.5</a></cite>).

      <tr><td>Overflow page             <td>
        If a B-Tree cell is too large to store within a B-Tree page, a
        portion of it is stored using a chain of one or more overflow pages
        (see section <cite><a href="#overflow_page_chains" title="Overflow Page Chains">2.3.5</a></cite>).

      <tr><td>Pointer-map page          <td>
        A database page used to store meta data only present in auto-vacuum
        databases (see section <cite><a href="#pointer_map_pages" title="Pointer Map Pages">2.5</a></cite>).

      <tr><td>Right child page          <td>
        Each internal B-Tree node page has one or more child pages. The
        rightmost of these (the one containing the largest key values) is
        known as the right child page.

      <tr><td>Root page                 <td>
        A root page is a database page used to store the root node of a
        B-Tree data structure.

      <tr><td>Schema layer file format  <td>
        An integer between 1 and 4 stored as a 4 byte big-endian integer at
        offset 44 of the <a class=defnlink href="#glossary_Database_header">database header</a> (section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>).
        Certain file format constructions may only be present in databases
        with a certain minimum schema layer file format value.

      <tr><td>Schema table              <td>
        The table B-Tree with root-page 1 used to store database records
        describing the database schema. Accessible as the "sqlite_master" 
        table from within SQLite.

      <tr><td>Schema version            <td>
        A 32-bit integer field stored at byte offset 40 of the <a class=defnlink href="#glossary_Database_file">database file</a>
        header (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>). Normally, SQLite
        increments this value each time it modifies the database schema.

      <tr><td>Table B-Tree              <td>
        One of two variants on the B-Tree data structure used within SQLite
        <a class=defnlink href="#glossary_Database_file">database files</a>. A table B-Tree (section <cite><a href="#table_btrees" title="Table B-Trees">2.3.4</a></cite>)
        uses 64 bit integers as key values and stores an associated database
        record along with each key value.

      <tr><td>User cookie               <td>
        A 32-bit integer field stored at byte offset 60 of the <a class=defnlink href="#glossary_Database_file">database file</a>
        header (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>). This value can be
        set and queried using the user_version PRAGMA but is not otherwise
        used by SQLite.

      <tr><td>Variable Length Integer   <td>
        A format used for storing 64-bit signed integer values in SQLite 
        <a class=defnlink href="#glossary_Database_file">database files</a>. Consumes between 1 and 9 bytes of space, depending
        on the precise value being stored.

      <tr><td>Well formed <a class=defnlink href="#glossary_Database_file">database file</a> <td>
        An SQLite <a class=defnlink href="#glossary_Database_file">database file</a> that meets all the criteria laid out in
        section <cite><a href="#database_file_format" title="Database Image Format Details">2</a></cite> of this document.

      <tr><td class=defn><a name="glossary_Database_image"></a><a class=defnlink href="#glossary_Database_image">Database image</a> <td>
        A serialized blob of data representing an SQLite database. The
        contents of a <a class=defnlink href="#glossary_Database_file">database file</a> are usually a valid <a class=defnlink href="#glossary_Database_image">database image</a>.
      
      <tr><td class=defn><a name="glossary_Database_file"></a><a class=defnlink href="#glossary_Database_file">Database file</a> <td>
        A <a class=defnlink href="#glossary_Database_file">database file</a> is a file on disk that usually, but not always,
        contains a well-formed <a class=defnlink href="#glossary_Database_image">database image</a>.
      
      <tr><td class=defn><a name="glossary_Journal_file"></a><a class=defnlink href="#glossary_Journal_file">Journal file</a> <td>
        For each <a class=defnlink href="#glossary_Database_file">database file</a>, there may exist an associated <a class=defnlink href="#glossary_Journal_file">journal file</a>
	stored in the same file-system directory. Under some circumstances,
	the <a class=defnlink href="#glossary_Database_image">database image</a> may be distributed between the database and <a class=defnlink href="#glossary_Journal_file">journal
	files</a> (instead of being stored wholly within the <a class=defnlink href="#glossary_Database_file">database file</a>).
      
      <tr><td class=defn><a name="glossary_Page_size"></a><a class=defnlink href="#glossary_Page_size">Page size</a> <td>
        An SQLite <a class=defnlink href="#glossary_Database_image">database image</a> is divided into fixed size pages, each 
        "<a class=defnlink href="#glossary_Page_size">page size</a>" bytes in size.
      
      <tr><td class=defn><a name="glossary_Sector_size"></a><a class=defnlink href="#glossary_Sector_size">Sector size</a> <td>
        In this document, the term "<a class=defnlink href="#glossary_Sector_size">sector size</a>" refers to a field in a
	<a class=defnlink href="#glossary_Journal_Header">journal header</a> which determines some aspects of the layout of the
	<a class=defnlink href="#glossary_Journal_file">journal file</a>. It is set by SQLite (or a compatible) application
	based on the properties of the underlying file-system that the <a class=defnlink href="#glossary_Journal_file">journal
	file</a> is being written to.
      
      <tr><td class=defn><a name="glossary_Journal_Section"></a><a class=defnlink href="#glossary_Journal_Section">Journal Section</a> <td>
	A <a class=defnlink href="#glossary_Journal_file">journal file</a> may contain multiple <a class=defnlink href="#glossary_Journal_Section">journal sections</a>. A <a class=defnlink href="#glossary_Journal_Section">journal section</a>
	consists of a <a class=defnlink href="#glossary_Journal_Header">journal header</a> followed by zero or more <a class=defnlink href="#glossary_Journal_Record">journal records</a>.
      
      <tr><td class=defn><a name="glossary_Journal_Header"></a><a class=defnlink href="#glossary_Journal_Header">Journal Header</a> <td>
	A <a class=defnlink href="#glossary_Journal_Header">journal header</a> is a control block <a class=defnlink href="#glossary_Sector_size">sector-size</a> bytes in size that
	appears at the start of each <a class=defnlink href="#glossary_Journal_Section">journal section</a> within a <a class=defnlink href="#glossary_Journal_file">journal file</a>.
      
      <tr><td class=defn><a name="glossary_Journal_Record"></a><a class=defnlink href="#glossary_Journal_Record">Journal Record</a> <td>
	A <a class=defnlink href="#glossary_Journal_Record">journal record</a> is a structure used to store data for a single
	database page within a <a class=defnlink href="#glossary_Journal_file">journal file</a>. A single <a class=defnlink href="#glossary_Journal_file">journal file</a> may contain
	many <a class=defnlink href="#glossary_Journal_Record">journal records</a>.
      
      <tr><td class=defn><a name="glossary_Master_Journal_Pointer"></a><a class=defnlink href="#glossary_Master_Journal_Pointer">Master Journal Pointer</a> <td>
        A <a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a> is a structure that may appear at the end of
	a <a class=defnlink href="#glossary_Journal_file">journal file</a>. It contains a full file-system path identifying 
	a master-<a class=defnlink href="#glossary_Journal_file">journal file</a>.
      
      <tr><td class=defn><a name="glossary_Database_File-System_Representation"></a><a class=defnlink href="#glossary_Database_File-System_Representation">Database File-System Representation</a> <td>
        A file or files within the file-system used to store an SQLite 
        <a class=defnlink href="#glossary_Database_image">database image</a>.
      

      <tr><td class=defn><a name="glossary_Database_user-cookie"></a><a class=defnlink href="#glossary_Database_user-cookie">Database user-cookie</a> <td>
        An SQLite database contains a single 32-bit signed integer field known
	as the <a class=defnlink href="#glossary_Database_user-cookie">database user-cookie</a>. Applications may read and write this field
	for any purpose.
      

    </table>

<!--
h1 "SQLite <a class=defnlink href="#glossary_Database_file">Database Files</a>" sqlite_database_files
 
  <p>
    The bulk of this document, section <cite><a href="#database_file_format" title="Database Image Format Details">2</a></cite>,
    contains the definition of a <i>well-formed SQLite <a class=defnlink href="#glossary_Database_file">database file</a></i>.
    SQLite is required to create <a class=defnlink href="#glossary_Database_file">database files</a> that meet this definition.

          <p class=req id=H30010><span>The system shall ensure that at the successful conclusion of a
database transaction the contents of the <a class=defnlink href="#glossary_Database_file">database file</a> constitute
a <i>well-formed SQLite <a class=defnlink href="#glossary_Database_file">database file</a></i>.</span> (C: *)</p>

  <p>
    Additionally, the <a class=defnlink href="#glossary_Database_file">database file</a> should contain a serialized version
    of the logical database produced by the transaction. For all but the
    most trivial logical databases, there are many possible serial 
    representations.

          <p class=req id=H30020><span>The system shall ensure that at the successful conclusion of a
database transaction the contents of the <a class=defnlink href="#glossary_Database_file">database file</a> are a valid
serialization of the contents of the logical SQL database produced
by the transaction.</span></p>
-->

<!--
  <p>
    Section <cite>database_file_manipulation</cite> contains requirements
    describing in more detail the way in which SQLite manipulates the
    fields and data structures described in section
    <cite><a href="#database_file_format" title="Database Image Format Details">2</a></cite> under various circumstances. These
    requirements are to a certain extent derived from the requirements 
    in this section.
-->
  

<h1 id="database_file_format">2 <a class=defnlink href="#glossary_Database_image">Database Image</a> Format Details</h1>


  <p>
    This section describes the various fields and sub-structures that make up
    the format used by SQLite to serialize a logical SQL database. A serialized
    logical database is referred to as a <a class=defnlink href="#glossary_Database_image">database image</a>. Section
    <cite><a href="#file_system_usage" title="Database File-System Representation">3</a></cite> describes the way a <a class=defnlink href="#glossary_Database_image">database image</a> is stored
    in the file-system. Most of the time a <a class=defnlink href="#glossary_Database_image">database image</a> is stored in a single
    file, the <a class=defnlink href="#glossary_Database_file">database file</a>. So while reading this section, the term <a class=defnlink href="#glossary_Database_image">database 
    image</a> may be understood to mean "contents of the <a class=defnlink href="#glossary_Database_file">database file</a>". However,
    it is important to remember that there are exceptions to this.

  <p>
    This section does not contain requirements governing the behaviour of any
    software system. Instead, along with the plain language description of the
    file format are a series of succinct, testable statements describing the
    properties of "well-formed SQLite <a class=defnlink href="#glossary_Database_file">database files</a>".  Some of these
    statements describe the contents of the <a class=defnlink href="#glossary_Database_file">database file</a> in terms of the
    contents of the logical SQL database that it is a serialization of. e.g.
    "For each SQL table in the database, the <a class=defnlink href="#glossary_Database_file">database file</a> shall...". The 
    contents of a logical database consist of:

  <ul>
    <li>The database schema: The set of database tables, virtual tables, 
        indexes, triggers and views stored in the database.

    <li>The database contents: The set of tuples (rows) stored in
	each database table.

    <li>Other database properties, as follows:
      <ol>
	<li>The <a class=defnlink href="#glossary_Page_size">page-size</a> of the database.
	<li>The text-encoding of the database.
	<li>A flag indicating whether or not the database is an auto-vacuum 
	    database.
	<li>The value of the <a class=defnlink href="#glossary_Database_user-cookie">database user-cookie</a>.
	<li>If the database is an auto-vacuum database, a flag indicating 
	    whether or not the database is in incremental vacuum mode or not.
	<li>The default page cache size in pages to use with the database (an 
	    integer field).
      </ol>
  </ul>

  <p>
    Of the six database properties enumerated above, the values taken by the
    initial three dramatically affect the structure of the <a class=defnlink href="#glossary_Database_image">database image</a>. Any
    software system that handles SQLite <a class=defnlink href="#glossary_Database_image">database images</a> will need to understand
    and interpret them. Properties 4 to 6 may be considered advisory. Although
    properties 5 and 6 modify the operation of the SQLite library in 
    well-defined manners, an alternative SQLite database client is free to
    interpret them differently, or not interpret them at all. 

  <p class=todo>
    The concept of a logical database and its contents should be defined
    properly in some requirements document so that it can be referenced from
    here and other places. The definition will be something like the list of
    bullet points above.

  <p>
    Many of the numbered requirements in the following sub-sections describe 
    the relationship between the contents of the logical database, as itemized
    above, and the contents of the serialized <a class=defnlink href="#glossary_Database_image">database image</a>. Others describe
    the relationships between various <a class=defnlink href="#glossary_Database_image">database image</a> substructures, invariants
    that are true for all well-formed <a class=defnlink href="#glossary_Database_image">database images</a>.

  <p>
    A well-formed SQLite <a class=defnlink href="#glossary_Database_image">database image</a> is defined as an image for which
    all of the statements itemized as requirements within this section
    are true. <span class=todo>mention the requirements numbering scheme
    here.</span> A software system that wishes to inter-operate with other
    systems using the SQLite <a class=defnlink href="#glossary_Database_image">database image</a> format should only ever
    output well-formed SQLite databases. In the case of SQLite itself,
    the system should ensure that the <a class=defnlink href="#glossary_Database_file">database file</a> contains a well-formed 
    <a class=defnlink href="#glossary_Database_image">database image</a> the conclusion of each transaction.

  <h2 id="fileformat_overview">2.1 Image Format Overview</h2>

    <p>
      A B-Tree is a data structure designed for offline storage of a set of
      unique key values. It is structured so as to support fast querying 
      for a single key or range of keys. As implemented in SQLite, each
      entry may be associated with a blob of data that is not part of the
      key. For the canonical introduction to the B-Tree and its variants, 
      refer to reference <cite><a href="#ref_comer_btree" title="">[1]</a></cite>. The B-Tree 
      implementation in SQLite also adopts some of the enhancements 
      suggested in <cite><a href="#ref_knuth_btree" title="">[2]</a></cite>.
    <p>
      An SQLite <a class=defnlink href="#glossary_Database_image">database image</a> contains one or more B-Tree structures. Each
      B-Tree structure stores the data for a single database table or 
      index. Hence each <a class=defnlink href="#glossary_Database_file">database file</a> contains a single B-Tree to store
      the contents of the <i>sqlite_master</i> table, and one B-Tree
      for each database table or index created by the user. If the database
      uses auto-increment integer primary keys, then the <a class=defnlink href="#glossary_Database_file">database file</a>
      also contains a B-Tree to store the contents of the automatically 
      created <i>sqlite_sequence</i> table.
    <p>
      SQLite uses two distinct variants of the B-Tree structure. One variant,
      hereafter referred to as a "table B-Tree" uses signed 64-bit integer
      values as keys. Each entry has an associated variable length blob of 
      data used to store a database record (see section
      <cite><a href="#record_format" title="Database Record Format">2.3.2</a></cite>). Each SQLite <a class=defnlink href="#glossary_Database_file">database file</a> contains one 
      table B-Tree for the schema table and one table B-Tree for each
      additional database table created by the user. If it is present, the
      sqlite_sequence table is also stored as a table B-Tree.
    <p>
      A database record is a blob of data containing an ordered list of
      SQL values (integers, real numbers, NULL values, blobs or strings).
      For each row in each table in the logical database, there is an 
      entry in the corresponding table B-Tree structure in the <a class=defnlink href="#glossary_Database_image">database 
      image</a>. The entry's integer key value is same as the SQL "rowid" or 
      "integer primary key" field of the table row. The associated database 
      record is made up of the row's column values, in declaration (CREATE 
      TABLE) order.
    <p>
      The other B-Tree variant used by SQLite, hereafter an "index B-Tree"
      uses database records (section <cite><a href="#record_format" title="Database Record Format">2.3.2</a></cite>) as keys.
      For this kind of B-Tree, there is no additional data associated with
      each entry. SQLite databases contain an index B-Tree for each database
      index created by the user. Database indexes may be created by CREATE
      INDEX statements, or by UNIQUE or PRIMARY KEY (but not INTEGER PRIMARY
      KEY) clauses added to CREATE TABLE statements. 
    <p>
      Index B-Tree structures contain one entry for each row in the 
      associated table in the logical SQL database. The database record used 
      as the key consists of the row's value for each of the indexed columns in
      declaration (CREATE INDEX) order, followed by the row's "rowid" or
      "integer primary key" column value.
    <p>
      For example, the following SQL script:
    <pre>
      CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c, d);
      CREATE INDEX i1 ON t1(d, c);

      INSERT INTO t1 VALUES(1, 'triangle', 3, 180, 'green');
      INSERT INTO t1 VALUES(2, 'square',   4, 360, 'gold');
      INSERT INTO t1 VALUES(3, 'pentagon', 5, 540, 'grey');
      ...</pre>
    <p>
      Creates a <a class=defnlink href="#glossary_Database_image">database image</a> containing three B-Tree structures: one table
      B-Tree to store the <i>sqlite_master</i> table, one table B-Tree to 
      store table "t1", and one index B-Tree to store index "i1". The
      B-Tree structures created for the user table and index are populated
      as shown in figure <cite><a href="#figure_examplepop" title="Example B-Tree Data">1</a></cite>.

      
      <center>
      <a name="figure_examplepop"></a>
      <img src="images/fileformat/examplepop.gif">
      <p><i>Figure 1 - Example B-Tree Data</i>
      </center>
  

    <p>
      The following sections and sub-sections describe precisely the format
      used to serialize the B-Tree structures within an SQLite <a class=defnlink href="#glossary_Database_image">database image</a>.

  <h2 id="section_2_2">2.2 Global Structure</h2>


    <h3 id="database_header">2.2.1 <a class=defnlink href="#glossary_Database_header">Database Header</a></h3>

      <p>
        An SQLite <a class=defnlink href="#glossary_Database_image">database image</a> begins with a 100-byte <a class=defnlink href="#glossary_Database_header">database header</a>. The <a class=defnlink href="#glossary_Database_header">database 
        header</a> consists of a well known 16-byte sequence followed by a series of
        1, 2 and 4 byte unsigned integers. All integers in the <a class=defnlink href="#glossary_Database_header">database header</a> (as
        well as the rest of the <a class=defnlink href="#glossary_Database_file">database file</a>) are stored in big-endian format.
        
      <p>
        The well known 16-byte sequence that begins every SQLite <a class=defnlink href="#glossary_Database_file">database file</a>
        is:
      <pre>
          0x53 0x51 0x4c 0x69 0x74 0x65 0x20 0x66 0x6f 0x72 0x6d 0x61 0x74 0x20 0x33 0x00</pre>

      <p>
        Interpreted as UTF-8 encoded text, this byte sequence corresponds 
        to the string "SQLite format 3" followed by a nul-terminator byte.

          <p class=req id=H30030><span>The first 16 bytes of a well-formed <a class=defnlink href="#glossary_Database_file">database file</a> shall contain 
the UTF-8 encoding of the string "SQLite format 3" followed by a 
single nul-terminator byte.</span></p>

      <p>
        The 1, 2 and 4 byte unsigned integers that make up the rest of the
        <a class=defnlink href="#glossary_Database_header">database header</a> are described in the following table.

      <table style="margin:1em auto;width:80%;border-spacing:0">
        <tr style="text-align:left"><th>Byte Range <th>Byte Size <th width=100%>Description <th>Reqs
	<tr style="text-align:left;background-color:#DDDDDD"><td>16..17 <td>2<td>
            Database <a class=defnlink href="#glossary_Page_size">page size</a> in bytes. See section 
            <cite><a href="#pages_and_page_types" title="Pages and Page Types">2.2.2</a></cite> for details.
            <td><a class=reqlink href=#H30190>H30190</a>

        <tr style="text-align:left"><td>18     <td>1<td>
            <p style="margin-top:0">
            File-format "write version". Currently, this field
            is always set to 1. If a value greater than 1 is read by SQLite,
            then the library will only open the file for read-only access.

            <p style="margin-bottom:0">
            This field and the next one are intended to be used for 
            forwards compatibility, should the need ever arise. If in the
            future a version of SQLite is created that uses a file format
            that may be safely read but not written by older versions of
            SQLite, then this field will be set to a value greater than 1
            to prevent older SQLite versions from writing to a file that
            uses the new format. 
            <td><a class=reqlink href=#H30040>H30040</a>

        <tr style="text-align:left;background-color:#DDDDDD"><td>19     <td>1<td>
            <p style="margin-top:0">
             File-format "read version". Currently, this 
            field is always set to 1. If a value greater than 1 is read 
            by SQLite, then the library will refuse to open the database 

            <p style="margin-bottom:0">
            Like the "write version" described above, this field exists
            to facilitate some degree of forwards compatibility, in case
            it is ever required. If a version of SQLite created in the 
            future uses a file format that may not be safely read by older
            SQLite versions, then this field will be set to a value greater
            than 1.
            <td><a class=reqlink href=#H30040>H30040</a>

        <tr style="text-align:left"><td>20     <td>1<td>
            Number of bytes of unused space at the end of each database
            page. Usually this field is set to 0. If it is non-zero, then 
            it contains the number of bytes that are left unused at the
            end of every database page (see section
            <cite><a href="#pages_and_page_types" title="Pages and Page Types">2.2.2</a></cite> for a description of a
            database page).
            <td><a class=reqlink href=#H30040>H30040</a>

        <tr style="text-align:left;background-color:#DDDDDD"><td>21     <td>1<td>
             Maximum fraction of an index tree page to use for 
            embedded content. This value is used to determine the maximum
            size of a B-Tree cell to store as embedded content on a
            page that is part of an index B-Tree. Refer to section 
            <cite><a href="#index_btree_cell_format" title="Index B-Tree Cell Format">2.3.3.4</a></cite> for details.
            <td><a class=reqlink href=#H30040>H30040</a>

        <tr style="text-align:left"><td>22     <td>1<td>
            Minimum fraction of an index B-Tree page to use for
            embedded content when an entry uses one or more overflow pages.
            This value is used to determine the portion of a B-Tree cell 
            that requires one or more overflow pages to store as embedded
            content on a page that is part of an index B-Tree. Refer to
            section <cite><a href="#index_btree_cell_format" title="Index B-Tree Cell Format">2.3.3.4</a></cite> for details.
            <td><a class=reqlink href=#H30040>H30040</a>

        <tr style="text-align:left;background-color:#DDDDDD"><td>23     <td>1<td>
            Minimum fraction of an table B-Tree leaf page to use for
            embedded content when an entry uses one or more overflow pages.
            This value is used to determine the portion of a B-Tree cell 
            that requires one or more overflow pages to store as embedded
            content on a page that is a leaf of a table B-Tree. Refer to
            section <cite><a href="#table_btree_cell_format" title="Table B-Tree Cell Format">2.3.4.3</a></cite> for details.
            <td><a class=reqlink href=#H30040>H30040</a>

        <tr style="text-align:left"><td>24..27 <td>4<td>
            <p style="margin-top:0">
            The file change counter. Each time a database transaction is
            committed, the value of the 32-bit unsigned integer stored in
            this field is incremented.
            <p style="margin-bottom:0">
            SQLite uses this field to test the validity of its internal
            cache. After unlocking the <a class=defnlink href="#glossary_Database_file">database file</a>, SQLite may retain
            a portion of the file cached in memory. However, since the file
            is unlocked, another process may use SQLite to modify the 
            contents of the file, invalidating the internal cache of the
            first process. When the file is relocked, the first process can
            check if the value of the file change counter has been modified
            since the file was unlocked. If it has not, then the internal
            cache may be assumed to be valid and may be reused.
            <td><a class=reqlink href=#H33040>H33040</a>

        <tr style="text-align:left;background-color:#DDDDDD"><td>32..35 <td>4<td>
            Page number of first freelist trunk page. 
            For more details, refer to section <cite><a href="#free_page_list" title="The Free Page List">2.4</a></cite>.
            <td><a class=reqlink href=#H31320>H31320</a>

        <tr style="text-align:left"><td>36..39 <td>4<td>
            Number of free pages in the <a class=defnlink href="#glossary_Database_file">database file</a>.
            For more details, refer to section <cite><a href="#free_page_list" title="The Free Page List">2.4</a></cite>.
            <td><a class=reqlink href=#H31310>H31310</a>

        <tr style="text-align:left;background-color:#DDDDDD"><td>40..43 <td>4<td>
            The schema version. Each time the database schema is modified (by
            creating or deleting a database table, index, trigger or view)
            the value of the 32-bit unsigned integer stored in this field
            is incremented.
            <td><a class=reqlink href=#H33050>H33050</a>

        <tr style="text-align:left"><td>44..47 <td>4<td>
            <p style="margin-top:0">
            Schema layer file-format. This value is similar to the
            "read-version" and "write-version" fields at offsets 18 and 19
            of the <a class=defnlink href="#glossary_Database_header">database header</a>. If SQLite encounters a database
            with a schema layer file-format value greater than the file-format
            that it understands (currently 4), then SQLite will refuse to
            access the database.
            <p>
            Usually, this value is set to 1. However, if any of the following
            file-format features are used, then the schema layer file-format
            must be set to the corresponding value or greater:
            <ol start=2 style="margin-bottom:0">
              <li> Implicit NULL values at the end of table records 
                   (see section <cite><a href="#table_btree_content" title="Table B-Tree Content">2.3.4.1</a></cite>).
              <li> Implicit default (non-NULL) values at the end of table
                   records (see section <cite><a href="#table_btree_content" title="Table B-Tree Content">2.3.4.1</a></cite>).
              <li> Descending indexes (see section
                   <cite><a href="#index_btree_compare_func" title="Record Sort Order">2.3.3.2</a></cite>) and Boolean values
                   in database records (see section <cite><a href="#record_format" title="Database Record Format">2.3.2</a></cite>,
                   serial types 8 and 9).
            </ol>

            <p class=todo>
              Turns out SQLite can be tricked into violating this. If you delete
	      all tables from a database and then VACUUM the database, the
              schema layer file-format field somehow gets set to 0.
            <td><a class=reqlink href=#H30120>H30120</a>

        <tr style="text-align:left;background-color:#DDDDDD"><td>48..51 <td>4<td>
            Default pager cache size. This field is used by SQLite to store
            the recommended pager cache size to use for the database.
            <td><a class=reqlink href=#H30130>H30130</a>

        <tr style="text-align:left"><td>52..55 <td>4<td>
            For auto-vacuum capable databases, the numerically largest 
            root-page number in the database. Since page 1 is always the
            root-page of the schema table (section <cite><a href="#schema_table" title="The Schema Table">2.2.3</a></cite>),
            this value is always non-zero for auto-vacuum databases. For
            non-auto-vacuum databases, this value is always zero.
            <td><a class=reqlink href=#H30140>H30140</a>, <a class=reqlink href=#H30141>H30141</a>

        <tr style="text-align:left;background-color:#DDDDDD"><td>56..59 <td>4<td>
            (constant) Database text encoding. A value of 1 means all 
            text values are stored using UTF-8 encoding. 2 indicates
            little-endian UTF-16 text. A value of 3 means that the database
            contains big-endian UTF-16 text.  
            <td><a class=reqlink href=#H30150>H30150</a>

        <tr style="text-align:left"><td>60..63 <td>4<td>
            The user-cookie value. A 32-bit integer value available to the
            user for read/write access.
            <td><a class=reqlink href=#H30160>H30160</a>

        <tr style="text-align:left;background-color:#DDDDDD"><td>64..67 <td>4<td>
            The incremental-vacuum flag. In non-auto-vacuum databases this
            value is always zero. In auto-vacuum databases, this field is
            set to 1 if "incremental vacuum" mode is enabled. If incremental
            vacuum mode is not enabled, then the <a class=defnlink href="#glossary_Database_file">database file</a> is reorganized
            so that it contains no free pages (section
            <cite><a href="#free_page_list" title="The Free Page List">2.4</a></cite>) at the end of each database
            transaction. If incremental vacuum mode is enabled, then the
            reorganization is not performed until explicitly requested
            by the user.
            <td><a class=reqlink href=#H30171>H30171</a>

      </table>

      <p>
        The four byte block beginning at offset 28 is unused. As is the
        32 byte block beginning at offset 68.
      </p>

      <p>
        The following requirements state that certain <a class=defnlink href="#glossary_Database_header">database header</a>
        fields must contain defined constant values, even though the sqlite 
        <a class=defnlink href="#glossary_Database_file">database file</a> format is designed to allow various values. These fields
        were intended to be flexible when the SQLite <a class=defnlink href="#glossary_Database_image">database image</a> format
        was designed, but it has since been determined that it is faster and
        safer to require these parameters to be populated with well-known 
        values. Specifically, in a well-formed database, the following header
        fields are always set to well-known values:

      <ul>
        <li> The file-format write version (single byte field, byte offset 18), 
             is always set to 0x01.
        <li> The file-format read version (single byte field, byte offset 19), 
             is always set to 0x01.
        <li> The number of unused bytes on each page (single byte field, byte 
             offset 20), is always set to 0x00.
        <li> The maximum fraction of an index B-Tree page to use for embedded content 
	     (single byte field, byte offset 21), is always set to 0x40.  <li>
	     The minimum fraction of an index B-Tree page to use for embedded
	     content when using overflow pages (single byte field, byte 
             offset 22), is always set to 0x20.
	<li> The minimum fraction of a table B-Tree page to use for embedded
	     content when using overflow pages (single byte field, byte offset 23),
	     is always set to 0x20.
      </ul>

      <p>
        The following requirement encompasses all of the above.

          <p class=req id=H30040><span>The 6 bytes beginning at byte offset 18 of a well-formed <a class=defnlink href="#glossary_Database_image">database 
image</a> shall contain the values 0x01, 0x01, 0x00, 0x40, 0x20 and 
0x20, respectively.</span></p>

      <p>
        Section <cite><a href="#database_file_format" title="Database Image Format Details">2</a></cite> identifies six persistent
        user-visible properties of an SQLite database. The following 
        requirements describe the way in which these properties are stored.

          <p class=req id=H30190><span>The 2-byte big-endian unsigned integer field at byte offset 16 of a
well-formed <a class=defnlink href="#glossary_Database_image">database image</a> shall be set to the value of the database
<a class=defnlink href="#glossary_Page_size">page-size</a>.</span></p>
          <p class=req id=H30191><span>The <a class=defnlink href="#glossary_Page_size">page-size</a> of an SQLite database in bytes shall be an integer power 
of 2 between 512 and 32768, inclusive.</span></p>
          <p class=req id=H30150><span>The 4 byte big-endian unsigned integer field at byte offset 56 of a 
well-formed <a class=defnlink href="#glossary_Database_image">database image</a> shall be set to 1 if the database text-encoding
is UTF-8, 2 if the database text-encoding is little-endian UTF-16, and 3
if the database text-encoding is big-endian UTF-16.</span></p>
          <p class=req id=H30140><span>If the database is not an auto-vacuum capable database, then the 4 byte 
big-endian unsigned integer field at byte offset 52 of a well-formed 
<a class=defnlink href="#glossary_Database_image">database image</a> shall contain the value 0.</span></p>
          <p class=req id=H30141><span>If the database is an auto-vacuum capable database, then the 4 byte 
big-endian unsigned integer field at byte offset 52 of a well-formed 
<a class=defnlink href="#glossary_Database_image">database image</a> shall contain the numerically largest root-page number 
of any table or index B-Tree within the <a class=defnlink href="#glossary_Database_image">database image</a>.</span></p>
          <p class=req id=H30160><span>The 4-byte big-endian unsigned integer field at byte offset 60 of a 
well-formed <a class=defnlink href="#glossary_Database_image">database image</a> shall be set to the value of the 
<a class=defnlink href="#glossary_Database_user-cookie">database user-cookie</a>.</span></p>
          <p class=req id=H30170><span>The 4-byte big-endian unsigned integer field at byte offset 64 of a
well-formed <a class=defnlink href="#glossary_Database_image">database image</a> shall be set to the value of the database
incremental-vacuum flag.</span></p>
          <p class=req id=H30171><span>The value of the incremental-vacuum flag of an SQLite database shall be
either 0 or 1.</span></p>
          <p class=req id=H30130><span>The 4-byte big-endian unsigned integer field at byte offset 48 of a 
well-formed <a class=defnlink href="#glossary_Database_image">database image</a> shall be set to the value of the 
database default page-cache size.</span></p>

      <p>
        The following requirement describes the valid range of values for the
        schema layer file format field.

          <p class=req id=H30120><span>The 4-byte big-endian signed integer field at byte offset 44 of a 
well-formed <a class=defnlink href="#glossary_Database_image">database image</a>, the schema layer file format field, 
shall be set to an integer value between 1 and 4, inclusive.</span></p>

      <p class=todo>
        See the note to do with the schema file format version above. Turns
        out this field may also be set to 0 by SQLite.

    <h3 id="pages_and_page_types">2.2.2 Pages and Page Types</h3>

      <p>
        The entire <a class=defnlink href="#glossary_Database_file">database file</a> is divided into pages, each page consisting
        of <i><a class=defnlink href="#glossary_Page_size">page-size</a></i> bytes, where <i><a class=defnlink href="#glossary_Page_size">page-size</a></i> is the 2-byte 
        integer value stored at offset 16 of the <a class=defnlink href="#glossary_Database_header">database header</a> (see above).
        The <i><a class=defnlink href="#glossary_Page_size">page-size</a></i> is always a power of two between 512 
        (2<sup>9</sup>) and 32768 (2<sup>15</sup>). SQLite <a class=defnlink href="#glossary_Database_file">database files</a>
        always consist of an exact number of pages.
      <p>
        Pages are numbered beginning from 1, not 0. Page 1 consists of
        the first <i><a class=defnlink href="#glossary_Page_size">page-size</a></i> bytes of the <a class=defnlink href="#glossary_Database_file">database file</a>. 
        The <a class=defnlink href="#glossary_Database_header">database header</a> described in the previous section consumes
        the first 100 bytes of page 1.
      <p>
        Each page of the <a class=defnlink href="#glossary_Database_file">database file</a> is one of the following:
      <ul>
        <li><b>A B-Tree page</b>. B-Tree pages are part of the tree 
            structures used to store database tables and indexes.
        <li><b>An overflow page</b>. Overflow pages are used by particularly
            large database records that do not fit on a single B-Tree page.
        <li><b>A free page</b>. Free pages are pages within the <a class=defnlink href="#glossary_Database_file">database file</a>
            that are not being used to store meaningful data.
        <li><b>A "pointer-map" page</b>. In auto-vacuum capable databases
            (databases for which the 4 byte big-endian integer stored at
            byte offset 52 of the <a class=defnlink href="#glossary_Database_header">database header</a> is non-zero) some pages are
            permanently designated "pointer-map" pages. See section 
            <cite><a href="#pointer_map_pages" title="Pointer Map Pages">2.5</a></cite> for details.
        <li><b>The locking page</b>. The database page that starts at
            byte offset 2<sup>30</sup>, if it is large enough to contain
            such a page, is always left unused.
      </ul>

          <p class=req id=H30200><span>The size of a well formed <a class=defnlink href="#glossary_Database_image">database image</a> shall be an integer
multiple of the database <a class=defnlink href="#glossary_Page_size">page size</a>.</span></p>
          <p class=req id=H30210><span>Each page of a well formed <a class=defnlink href="#glossary_Database_image">database image</a> shall be exactly one of a
<i>B-Tree page</i>, an <i>overflow page</i>, a <i>free page</i>, a
<i>pointer-map page</i> or the <i>locking page</i>.</span></p>
          <p class=req id=H30220><span>The database page that starts at byte offset 2<sup>30</sup>, the
<i>locking page</i>, shall never be used for any purpose.</span></p>
        

    <h3 id="schema_table">2.2.3 The Schema Table</h3>

      <p>
        Apart from being the page that contains the file-header, page 1 of
        a <a class=defnlink href="#glossary_Database_image">database image</a> is special because it is the root page of the
        B-Tree structure that contains the schema table data. From the SQL
        level, the schema table is accessible via the name "sqlite_master".
      <p>
        The exact format of the B-Tree structure and the meaning of the term
        "root page" is discussed in section <cite><a href="#btree_structures" title="B-Tree Structures">2.3</a></cite>.
        For now, it is sufficient to know that the B-Tree structure is a
        data structure that stores a set of records. Each record is an
        ordered set of SQL values (the format of which is described in
        section <cite><a href="#record_format" title="Database Record Format">2.3.2</a></cite>). Given the root page number of
        the B-Tree structure (which is well known for the schema table), it
        is possible to iterate through the set of records.
      <p>
        The schema table contains a record for each SQL table (including
        virtual tables) except for sqlite_master, and for each index, trigger
        and view in the logical database.  There is also an entry for each
        UNIQUE or PRIMARY KEY clause present in the definition of a database
        table. Each record in the schema table contains exactly 5 values, in
        the following order:

      <table style="margin:1em auto;width:80%;border-spacing:0">
        <tr style="text-align:left"><th>Field<th>Description
        <tr style="text-align:left;background-color:#DDDDDD"><td>Schema item type.
            <td>A string value. One of "table", "index", "trigger" or "view",
                according to the schema item type. Entries associated with
                UNIQUE or PRIMARY KEY clauses have this field set to "index".
        <tr style="text-align:left"><td>Schema item name.
            <td>A string value. The name of the database schema item (table,
                index, trigger or view) associated with this record, if any.
                Entries associated with UNIQUE or PRIMARY KEY clauses have
                this field set to a string of the form
                "sqlite_autoindex_&lt;name&gt;_&lt;idx&gt;" where &lt;name&gt;
                is the name of the SQL table and &lt;idx&gt; is an integer
                value.

        <tr style="text-align:left;background-color:#DDDDDD"><td style="white-space:nowrap">Associated table name.
            <td>A string value. For "table" 
            or "view" records this is a copy of the second (previous) value. 
            For "index" and "trigger" records, this field is set to the name 
            of the associated database table.
        <tr style="text-align:left"><td style="white-space:nowrap">The "root page" number. 
            <td>For "trigger" and "view" records, as well as "table" records
	        associated with virtual tables, this is set to integer value 0. 
		For other "table" and "index" records (including those associated 
		with UNIQUE or PRIMARY KEY clauses), this field contains the root
                page number (an integer) of the B-Tree structure that contains
                the table or index data.
        <tr style="text-align:left;background-color:#DDDDDD"><td>The SQL statement.
            <td>A string value. The SQL statement used to create the schema
                item (i.e.  the complete text of an SQL "CREATE TABLE"
                statement). This field contains an empty string for table
                entries associated with PRIMARY KEY or UNIQUE clauses.
                <span class=todo>Refer to some document that describes these
                SQL statements more precisely.</span>
      </table>
      <p>
        Logical database schema items other than non-virtual tables and indexes
        (including indexes created by UNIQUE or PRIMARY key constraints) do not
        require any other data structures to be created within the <a class=defnlink href="#glossary_Database_file">database
        file</a>.

      <p>
        Tables and indexes on the other hand, are represented within the
        <a class=defnlink href="#glossary_Database_file">database file</a> by both an entry in the schema table and a B-Tree
        structure stored elsewhere in the file. The specific B-Tree associated
        with each database table or index is identified by its root page
        number, which is stored in the 4th field of the schema table record.
        In a non-auto-vacuum database, the B-Tree root pages may be stored
        anywhere within the <a class=defnlink href="#glossary_Database_file">database file</a>. For an auto-vacuum database, all
        B-Tree root pages must at all times form a contiguous set starting
        at page 3 of the <a class=defnlink href="#glossary_Database_file">database file</a>, skipping any pages that are required to
        be used as pointer-map pages (see section
        <cite><a href="#pointer_map_pages" title="Pointer Map Pages">2.5</a></cite>).
      <p>
        As noted in section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>, in an auto-vacuum
        database the page number of the page immediately following the
        final root page in the contiguous set of root pages is stored
        as a 4 byte big-endian integer at byte offset 52 of the <a class=defnlink href="#glossary_Database_header">database
        header</a>. Unless that page is itself a pointer-map page, in which
        case the page number of the page following it is stored instead.

      <p>
        For example, if the schema of a logical database is created using
        the following SQL statements:
      <pre>
          CREATE TABLE abc(a, b, c);
          CREATE INDEX i1 ON abc(b, c);
          CREATE TABLE main.def(a PRIMARY KEY, b, c, UNIQUE(b, c));
          CREATE VIEW v1 AS SELECT * FROM abc;
      </pre>
      <p>
        Then the schema table would contain a total of 7 records, as follows:

      <table style="margin:1em auto;width:80%;border-spacing:0">
        <tr style="text-align:left"><th>Field 1<th>Field 2<th>Field 3<th>Field 4<th>Field 5
        <tr style="text-align:left;background-color:#DDDDDD"><td>table <td>abc <td>abc <td>2 <td>CREATE TABLE abc(a, b, c)
        <tr style="text-align:left"><td>index <td>i1 <td>abc <td>3 <td>CREATE INDEX i1 ON abc(b, c)
        <tr style="text-align:left;background-color:#DDDDDD"><td>table <td>def <td>def <td>4 <td>CREATE TABLE def(a PRIMARY KEY, b, c, UNIQUE(b, c))
        <tr style="text-align:left"><td>index <td>sqlite_autoindex_def_1 <td>def <td>5 <td>
        <tr style="text-align:left;background-color:#DDDDDD"><td>index <td>sqlite_autoindex_def_2 <td>def <td>6 <td>
        <tr style="text-align:left"><td>view <td>v1 <td>v1 <td>0 <td>CREATE VIEW v1 AS SELECT * FROM abc
      </table>

          <p class=req id=H30230><span>In a <i>well-formed <a class=defnlink href="#glossary_Database_file">database file</a></i>, the portion of the first
database page not consumed by the <a class=defnlink href="#glossary_Database_file">database file</a>-header (all but the
first 100 bytes) contains the root node of a table B-Tree,
the <i>schema table</i>.</span></p>
          <p class=req id=H30240><span>All records stored in the <i>schema table</i> contain exactly five
fields.</span></p>

      <p>The following requirements describe "table" records.

          <p class=req id=H30250><span>For each SQL table in the database apart from itself
("sqlite_master"), the <i>schema table</i> of a <i>well-formed
<a class=defnlink href="#glossary_Database_file">database file</a></i> contains an associated record.</span></p>
          <p class=req id=H30260><span>The first field of each <i>schema table</i> record associated with an
SQL table shall be the text value "table".</span></p>
          <p class=req id=H30270><span>The second field of each <i>schema table</i> record associated with an
SQL table shall be a text value set to the name of the SQL table.</span></p>
          <p class=req id=H30280><span>In a <i>well-formed <a class=defnlink href="#glossary_Database_file">database file</a></i>, the third field of all
<i>schema table</i> records associated with SQL tables shall contain
the same value as the second field.</span></p>
          <p class=req id=H30290><span>In a <i>well-formed <a class=defnlink href="#glossary_Database_file">database file</a></i>, the fourth field of all
<i>schema table</i> records associated with SQL tables that are not
virtual tables contains the page number (an integer value) of the root
page of the associated <i>table B-Tree</i> structure within the
<a class=defnlink href="#glossary_Database_file">database file</a>.</span></p>
          <p class=req id=H30300><span>If the associated database table is a virtual table, the fourth
field of the <i>schema table</i> record shall contain the integer
value 0 (zero).</span></p>
          <p class=req id=H30310><span>In a well-formed database, the fifth field of all <i>schema table</i>
records associated with SQL tables shall contain a "CREATE TABLE"
or "CREATE VIRTUAL TABLE" statment (a text value).  The details
of the statement shall be such that executing the statement
would create a table of precisely the same name and schema as the
existing database table.</span></p>

      <p>The following requirements describe "implicit index" records.

          <p class=req id=H30320><span>For each PRIMARY KEY or UNIQUE constraint present in the definition
of each SQL table in the database, the schema table of a well-formed
database shall contain a record with the first field set to the text
value "index", and the second field set to a text value containing a
string of the form "sqlite_autoindex_&lt;name&gt;_&lt;idx&gt;", where
&lt;name&gt; is the name of the SQL table and &lt;idx&gt; is an
integer value.</span></p>
          <p class=req id=H30330><span>In a well-formed database, the third field of all schema table
records associated with SQL PRIMARY KEY or UNIQUE constraints shall
contain the name of the table to which the constraint applies (a
text value).</span></p>
          <p class=req id=H30340><span>In a well-formed database, the fourth field of all schema table
records associated with SQL PRIMARY KEY or UNIQUE constraints shall
contain the page number (an integer value) of the root page of the
associated index B-Tree structure.</span></p>
          <p class=req id=H30350><span>In a well-formed database, the fifth field of all schema table
records associated with SQL PRIMARY KEY or UNIQUE constraints shall
contain an SQL NULL value.</span></p>

      <p>The following requirements describe "explicit index" records.

          <p class=req id=H30360><span>For each SQL index in the database, the schema table of a well-formed
database shall contain a record with the first field set to the text
value "index" and the second field set to a text value containing the
name of the SQL index.</span></p>
          <p class=req id=H30370><span>In a well-formed database, the third field of all schema table
records associated with SQL indexes shall contain the name of the
SQL table that the index applies to.</span></p>
          <p class=req id=H30380><span>In a well-formed database, the fourth field of all schema table
records associated with SQL indexes shall contain the page number
(an integer value) of the root page of the associated index B-Tree
structure.</span></p>
          <p class=req id=H30390><span>In a well-formed database, the fifth field of all schema table
records associated with SQL indexes shall contain an SQL "CREATE
INDEX" statement (a text value). The details of the statement shall
be such that executing the statement would create an index of
precisely the same name and content as the existing database index.</span></p>

      <p>The following requirements describe "view" records.

          <p class=req id=H30400><span>For each SQL view in the database, the schema table of a well-formed
database shall contain a record with the first field set to the text
value "view" and the second field set to a text value containing the
name of the SQL view.</span></p>
          <p class=req id=H30410><span>In a well-formed database, the third field of all schema table
records associated with SQL views shall contain the same value as
the second field.</span></p>
          <p class=req id=H30420><span>In a well-formed database, the third field of all schema table
records associated with SQL views shall contain the integer value 0.</span></p>
          <p class=req id=H30430><span>In a well-formed database, the fifth field of all schema table
records associated with SQL indexes shall contain an SQL "CREATE
VIEW" statement (a text value). The details of the statement shall
be such that executing the statement would create a view of
precisely the same name and definition as the existing database view.</span></p>

      <p>The following requirements describe "trigger" records.

          <p class=req id=H30440><span>For each SQL trigger in the database, the schema table of a well-formed
database shall contain a record with the first field set to the text
value "trigger" and the second field set to a text value containing the
name of the SQL trigger.</span></p>
          <p class=req id=H30450><span>In a well-formed database, the third field of all schema table
records associated with SQL triggers shall contain the name of the
database table or view to which the trigger applies.</span></p>
          <p class=req id=H30460><span>In a well-formed database, the third field of all schema table
records associated with SQL triggers shall contain the integer value 0.</span></p>
          <p class=req id=H30470><span>In a well-formed database, the fifth field of all schema table
records associated with SQL indexes shall contain an SQL "CREATE
TRIGGER" statement (a text value). The details of the statement shall
be such that executing the statement would create a trigger of
precisely the same name and definition as the existing database trigger.</span></p>

      <p>The following requirements describe the placement of B-Tree root 
         pages in auto-vacuum databases.

          <p class=req id=H30480><span>In an auto-vacuum database, all pages that occur before the page
number stored in the <i>auto-vacuum last root-page</i> field
of the <a class=defnlink href="#glossary_Database_file">database file</a> header (see <a class=reqlink href=#H30140>H30140</a>) must be either B-Tree <i>root
pages</i>, <i>pointer-map pages</i> or the <i>locking page</i>.</span></p>
          <p class=req id=H30490><span>In an auto-vacuum database, no B-Tree <i>root pages</i> may occur
on or after the page number stored in the <i>auto-vacuum last root-page</i> field
of the <a class=defnlink href="#glossary_Database_file">database file</a> header (see <a class=reqlink href=#H30140>H30140</a>) must be either B-Tree <i>root
pages</i>, <i>pointer-map pages</i> or the <i>locking page</i>.</span></p>

 
  <h2 id="btree_structures">2.3 B-Tree Structures</h2>

    <p>
      A large part of any SQLite <a class=defnlink href="#glossary_Database_file">database file</a> is given over to one or more
      B-Tree structures. A single B-Tree structure is stored using one or more
      database pages. Each page contains a single B-Tree node.
      The pages used to store a single B-Tree structure need not form a
      contiguous block. The page that contains the root node of a B-Tree
      structure is known as the "root page".

    <p>
      SQLite uses two distinct variants of the B-Tree structure:
    <ul>
      <li>The <b>table B-Tree</b>, which uses 64-bit integer values for keys. 
          In a table B-Tree, an associated database record (section
          <cite><a href="#record_format" title="Database Record Format">2.3.2</a></cite>) is stored along with each entry. Table
          B-Tree structures are described in detail in section 
          <cite><a href="#table_btrees" title="Table B-Trees">2.3.4</a></cite>.
      <li>The <b>index B-Tree</b>, which uses database records as keys. Index
          B-Tree structures are described in detail in section 
          <cite><a href="#index_btrees" title="Index B-Trees">2.3.3</a></cite>.
    </ul>

          <p class=req id=H30500><span>As well as the <i>schema table</i>, a <i>well-formed <a class=defnlink href="#glossary_Database_file">database file</a></i>
contains <i>N</i> table B-Tree structures, where <i>N</i> is the
number of non-virtual tables in the logical database, excluding the
sqlite_master table but including sqlite_sequence and other system
tables.</span></p>
          <p class=req id=H30510><span>A well-formed <a class=defnlink href="#glossary_Database_file">database file</a> contains <i>N</i> table B-Tree structures,
where <i>N</i> is the number of indexes in the logical database,
including indexes created by UNIQUE or PRIMARY KEY clauses in the
declaration of SQL tables.</span></p>

    <h3 id="varint_format">2.3.1 Variable Length Integer Format</h3>

      <p>
        In several parts of the B-Tree structure, 64-bit twos-complement signed
        integer values are stored in the "variable length integer format"
        described here.
      <p>
        A variable length integer consumes from one to nine bytes of space,
        depending on the value stored. Seven bits are used from each of
        the first eight bytes present, and, if present, all eight from
        the final ninth byte. Unless the full nine byte format is used, the
        serialized form consists of all bytes up to and including the first
        byte with the 0x80 bit cleared.
      <p>
        The number of bytes present depends on the position of the most
        significant set bit in the 64-bit word. Negative numbers always have
        the most significant bit of the word (the sign bit) set and so are
        always encoded using the full nine bytes. Positive integers may be
        encoded using less space. The following table shows the 9 different
        length formats available for storing a variable length integer
        value.

      <table style="margin:1em auto;width:80%;border-spacing:0">
        <tr style="text-align:left"><th>Bytes<th>Value Range<th>Bit Pattern
        <tr style="text-align:left;background-color:#DDDDDD"><td>1<td>7 bit<td>0xxxxxxx
        <tr style="text-align:left"><td>2<td>14 bit<td>1xxxxxxx 0xxxxxxx
        <tr style="text-align:left;background-color:#DDDDDD"><td>3<td>21 bit<td>1xxxxxxx 1xxxxxxx 0xxxxxxx
        <tr style="text-align:left"><td>4<td>28 bit<td>1xxxxxxx 1xxxxxxx 1xxxxxxx 0xxxxxxx
        <tr style="text-align:left;background-color:#DDDDDD"><td>5<td>35 bit<td>1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 0xxxxxxx
        <tr style="text-align:left"><td>6<td>42 bit<td>1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 0xxxxxxx
        <tr style="text-align:left;background-color:#DDDDDD"><td>7<td>49 bit<td>1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 0xxxxxxx
        <tr style="text-align:left"><td>8<td>56 bit<td>1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 0xxxxxxx
        <tr style="text-align:left;background-color:#DDDDDD"><td>9<td>64 bit<td>1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx xxxxxxxx
      </table>
      <p>
        When using the full 9 byte representation, the first byte contains
        the 7 most significant bits of the 64-bit value. The final byte of
        the 9 byte representation contains the 8 least significant bits of
        the 64-bit value. When using one of the other representations, the
        final byte contains the 7 least significant bits of the 64-bit value.
        The second last byte, if present, contains the 7 next least significant
        bits of the value, and so on. The significant bits of the 64-bit
        value for which no storage is provided are assumed to be zero.
      <p>
        When encoding a variable length integer, SQLite usually selects the
        most compact representation that provides enough storage to accommodate
        the most significant set bit of the value. This is not required
        however, using more bytes than is strictly necessary when encoding
        an integer is valid.

      <table style="margin:1em auto;width:80%;border-spacing:0">
        <tr style="text-align:left"><th>Decimal<th>Hexadecimal        <th>Variable Length Integer
        <tr style="text-align:left;background-color:#DDDDDD"><td>43     <td>0x000000000000002B <td>0x2B
        <tr style="text-align:left"><td>200815 <td>0x000000000003106F <td>0x8C 0xA0 0x6F
        <tr style="text-align:left;background-color:#DDDDDD"><td>-1     <td>0xFFFFFFFFFFFFFFFF 
            <td>0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
        <tr style="text-align:left"><td>-78506 <td>0xFFFFFFFFFFFECD56
            <td>0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFD 0xCD 0x56
      </table>

          <p class=req id=H30520><span>A 64-bit signed integer value stored in <i>variable length integer</i>
format consumes from 1 to 9 bytes of space.</span></p>
          <p class=req id=H30530><span>The most significant bit of all bytes except the last in a serialized
<i>variable length integer</i> is always set. Unless the serialized
form consumes the maximum 9 bytes available, then the most significant
bit of the final byte of the representation is always cleared.</span></p>
          <p class=req id=H30540><span>The eight least significant bytes of the 64-bit twos-compliment
representation of a value stored in a 9 byte <i>variable length
integer</i> are stored in the final byte (byte offset 8) of the
serialized <i>variable length integer</i>. The other 56 bits are
stored in the 7 least significant bits of each of the first 8 bytes
of the serialized <i>variable length integer</i>, in order from
most significant to least significant.</span></p>
          <p class=req id=H30550><span>A <i>variable length integer</i> that consumes less than 9 bytes of
space contains a value represented as an <i>N</i>-bit unsigned
integer, where <i>N</i> is equal to the number of bytes consumed by
the serial representation (between 1 and 8) multiplied by 7. The
<i>N</i> bits are stored in the 7 least significant bits of each
byte of the serial representation, from most to least significant.</span></p>
      

    <h3 id="record_format">2.3.2 Database Record Format</h3>

      <p>
        A database record is a blob of data that represents an ordered
        list of one or more SQL values. Database records are used in two
        places in SQLite <a class=defnlink href="#glossary_Database_file">database files</a> - as the associated data for entries
        in table B-Tree structures, and as the key values in index B-Tree
        structures. The size (number of bytes consumed by) a database record
        depends on the values it contains.
      <p>
        Each database record consists of a short record header followed by 
        a data area. The record header consists of <i>N+1</i> variable
        length integers (see section <cite><a href="#varint_format" title="Variable Length Integer Format">2.3.1</a></cite>), where
        <i>N</i> is the number of values stored in the record.
      <p>
        The first variable length integer in a record header contains the
        size of the record header in bytes. The following <i>N</i> variable
        length integer values each describe the type and size of the 
	corresponding SQL value within the record (the second integer in the 
	record header describes the first value in the record, etc.). The
	second and subsequent integer values in a record header are interpreted
	according to the following table:
      <table style="margin:1em auto;width:80%;border-spacing:0">
        <tr style="text-align:left"><th>Header Value <th>Data type and size
        <tr style="text-align:left;background-color:#DDDDDD"><td>0 
            <td>An SQL NULL value (type SQLITE_NULL). This value
                consumes zero bytes of space in the record's data area.
        <tr style="text-align:left"><td>1
            <td>An SQL integer value (type SQLITE_INTEGER), stored as a
                big-endian 1-byte signed integer.
        <tr style="text-align:left;background-color:#DDDDDD"><td>2
            <td>An SQL integer value (type SQLITE_INTEGER), stored as a
                big-endian 2-byte signed integer.
        <tr style="text-align:left"><td>3
            <td>An SQL integer value (type SQLITE_INTEGER), stored as a
                big-endian 3-byte signed integer.
        <tr style="text-align:left;background-color:#DDDDDD"><td>4
            <td>An SQL integer value (type SQLITE_INTEGER), stored as a
                big-endian 4-byte signed integer.
        <tr style="text-align:left"><td>5
            <td>An SQL integer value (type SQLITE_INTEGER), stored as a
                big-endian 6-byte signed integer.
        <tr style="text-align:left;background-color:#DDDDDD"><td>6
            <td>An SQL integer value (type SQLITE_INTEGER), stored as an
                big-endian 8-byte signed integer.
        <tr style="text-align:left"><td>7
            <td>An SQL real value (type SQLITE_FLOAT), stored as an
                8-byte IEEE floating point value.
        <tr style="text-align:left;background-color:#DDDDDD"><td>8
            <td>The literal SQL integer 0 (type SQLITE_INTEGER). The value 
                consumes zero bytes of space in the record's data area.
                Values of this type are only present in databases with
                a schema file format (the 32-bit integer at byte offset 44
                of the <a class=defnlink href="#glossary_Database_header">database header</a>) value of 4 or greater.

        <tr style="text-align:left"><td>9
            <td>The literal SQL integer 1 (type SQLITE_INTEGER). The value
                consumes zero bytes of space in the record's data area.
                Values of this type are only present in databases with
                a schema file format (the 32-bit integer at byte offset 44
                of the <a class=defnlink href="#glossary_Database_header">database header</a>) value of 4 or greater.

        <tr style="text-align:left;background-color:#DDDDDD"><td style="white-space:nowrap"><i>bytes</i> * 2 + 12
	    <td>Even values greater than or equal to 12 are used to signify a 
	        blob of data (type SQLITE_BLOB) (<i>n</i>-12)/2 bytes in length, 
	        where <i>n</i> is the integer value stored in the record header.
                
        <tr style="text-align:left"><td style="white-space:nowrap"><i>bytes</i> * 2 + 13
            <td>Odd values greater than 12 are used to signify a string
                (type SQLITE_TEXT) (<i>n</i>-13)/2 bytes in length, where
                <i>n</i> is the integer value stored in the record header.
      </table>
      <p>
        Immediately following the record header is the data for each
        of the record's values. A record containing <i>N</i> values is
        depicted in figure <cite><a href="#figure_recordformat" title="Database Record Format">2</a></cite>.

        
      <center>
      <a name="figure_recordformat"></a>
      <img src="images/fileformat/recordformat.gif">
      <p><i>Figure 2 - Database Record Format</i>
      </center>
  
      
      <p>
        For each SQL value in the record, there is a blob of data stored
        in the records data area. If the corresponding integer type value
        in the record header is 0 (NULL), 8 (integer value 0) or 9 (integer
        value 1), then the blob of data is zero bytes in length. Otherwise,
        the length of the data field is as described in the table above.
      <p>
        The data field associated with a string value contains the string
        encoded using the database encoding, as defined in the <a class=defnlink href="#glossary_Database_header">database
        header</a> (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>). No 
        nul-terminator character is stored in the database.

          <p class=req id=H30560><span>A <i>database record</i> consists of a <i>database record header</i>,
followed by <i>database record data</i>. The first part of the
<i>database record header</i> is a <i>variable length integer</i>
containing the total size (including itself) of the header in bytes.</span></p>
          <p class=req id=H30570><span>Following the length field, the remainder of the <i>database record
header</i> is populated with <i>N</i> <i>variable length integer</i>
fields, where <i>N</i> is the number of database values stored in
the record.</span></p>
          <p class=req id=H30580><span>Following the <i>database record header</i>, the <i>database record
data</i> is made up of <i>N</i> variable length blobs of data, where
<i>N</i> is again the number of database values stored in the record.
The <i>n</i> blob contains the data for the <i>n</i>th value in
the database record. The size and format of each blob of data is
encoded in the corresponding <i>variable length integer</i> field
in the <i>database record header</i>.</span></p>
          <p class=req id=H30590><span>A value of 0 stored within the <i>database record header</i> indicates
that the corresponding database value is an SQL NULL. In this case
the blob of data in the data area is 0 bytes in size.</span></p>
          <p class=req id=H30600><span>A value of 1 stored within the <i>database record header</i> indicates
that the corresponding database value is an SQL integer. In this case
the blob of data contains the integer value, formatted as a 1-byte
big-endian signed integer.</span></p>
          <p class=req id=H30610><span>A value of 2 stored within the <i>database record header</i> indicates
that the corresponding database value is an SQL integer. In this case
the blob of data contains the integer value, formatted as a 2-byte
big-endian signed integer.</span></p>
          <p class=req id=H30620><span>A value of 3 stored within the <i>database record header</i> indicates
that the corresponding database value is an SQL integer. In this case
the blob of data contains the integer value, formatted as a 3-byte
big-endian signed integer.</span></p>
          <p class=req id=H30630><span>A value of 4 stored within the <i>database record header</i> indicates
that the corresponding database value is an SQL integer. In this case
the blob of data contains the integer value, formatted as a 4-byte
big-endian signed integer.</span></p>
          <p class=req id=H30640><span>A value of 5 stored within the <i>database record header</i> indicates
that the corresponding database value is an SQL integer. In this case
the blob of data contains the integer value, formatted as a 6-byte
big-endian signed integer.</span></p>
          <p class=req id=H30650><span>A value of 6 stored within the <i>database record header</i> indicates
that the corresponding database value is an SQL integer. In this case
the blob of data contains the integer value, formatted as a 8-byte
big-endian signed integer.</span></p>
          <p class=req id=H30660><span>A value of 7 stored within the <i>database record header</i> indicates
that the corresponding database value is an SQL real (floating
point number). In this case the blob of data contains an 8-byte
IEEE floating point number, stored in big-endian byte order.</span></p>
          <p class=req id=H30670><span>A value of 8 stored within the <i>database record header</i> indicates
that the corresponding database value is an SQL integer, value 0.
In this case the blob of data in the data area is 0 bytes in size.</span></p>
          <p class=req id=H30680><span>A value of 9 stored within the <i>database record header</i> indicates
that the corresponding database value is an SQL integer, value 1.
In this case the blob of data in the data area is 0 bytes in size.</span></p>
          <p class=req id=H30690><span>An even value greater than or equal to 12 stored within the
<i>database record header</i> indicates that the corresponding
database value is an SQL blob field. The blob of data contains the
value data.  The blob of data is exactly (<i>n</i>-12)/2 bytes
in size, where <i>n</i> is the integer value stored in the
<i>database record header</i>.</span></p>
          <p class=req id=H30700><span>An odd value greater than or equal to 13 stored within the
<i>database record header</i> indicates that the corresponding
database value is an SQL text field. The blob of data contains the
value text stored using the <i>database encoding</i>, with no
nul-terminator. The blob of data is exactly (<i>n</i>-12)/2 bytes
in size, where <i>n</i> is the integer value stored in the
<i>database record header</i>.</span></p>

      <p>
        The following <a class=defnlink href="#glossary_Database_file">database file</a> properties define restrictions on the 
        integer values that may be stored within a 
        <i>database record header</i>.

          <p class=req id=H30710><span>In a well-formed <a class=defnlink href="#glossary_Database_file">database file</a>, if the values 8 or 9 appear within
any <i>database record header</i> within the database, then the
<i>schema-layer file format</i> (stored at byte offset 44 of the
<a class=defnlink href="#glossary_Database_file">database file</a> header) must be set to 4.</span></p>
          <p class=req id=H30720><span>In a well-formed <a class=defnlink href="#glossary_Database_file">database file</a>, the values 10 and 11, and all
negative values may not appear within any <i>database record header</i>
in the database.</span></p>

    <h3 id="index_btrees">2.3.3 Index B-Trees</h3>

      <p>
        As specified in section <cite><a href="#fileformat_overview" title="Image Format Overview">2.1</a></cite>, index 
        B-Tree structures store a unique set of the database records described
        in the previous section. While in some cases, when there are very
        few entries in the B-Tree, the entire structure may fit on a single
        database page, usually the database records must be spread across
        two or more pages. In this case, the pages are organized into a
        tree structure with a single "root" page at the head of the tree.
      <p>
        Within the tree structure, each page is either an internal tree 
        node containing an ordered list of N references to child nodes 
        (page numbers) and N-1 database records, or a leaf node containing 
        M database records. The value of N may be different for each page, but
        is always two or greater. Similarly, each leaf page may have a
        different non-zero positive value for M. The tree is always of
        uniform height, meaning the number of intermediate levels between 
        each leaf node page and the root page is the same.
      <p>
        Within both internal and leaf node pages, the records are stored in
        sorted order. The comparison function used to determine the sort order
        is described in section <cite><a href="#index_btree_compare_func" title="Record Sort Order">2.3.3.2</a></cite>.
      <p>
        Records are distributed throughout the tree such that for each 
        internal node, all records stored in the sub-tree headed by 
        the first child node ( C(0) ) are considered less than 
        the first record stored on the internal node ( R(0) ) by the 
        comparison function described in section
        <cite><a href="#index_btree_compare_func" title="Record Sort Order">2.3.3.2</a></cite>. Similarly all records stored 
        in the sub-tree headed by C(n) are considered greater than R(n-1) but
        less than R(n) for values of n between 1 and N-2, inclusive. All
        records in the sub-tree headed by C(N-1) are greater than the 
        largest record stored on the internal node.

        
      <center>
      <a name="figure_indextree"></a>
      <img src="images/fileformat/indextree.gif">
      <p><i>Figure 3 - Index B-Tree Tree Structure</i>
      </center>
  

      <p>
        Figure <cite><a href="#figure_indextree" title="Index B-Tree Tree Structure">3</a></cite> depicts one possible record
        distribution for an index B-Tree containing records R1 to R26, assuming
        that for all values of N, <i>R(N+1)&gt;R(N)</i>. In total the B-Tree
        structure uses 11 <a class=defnlink href="#glossary_Database_file">database file</a> pages. Internal tree nodes contain
        database records and references to child node pages. Leaf nodes contain
        database records only.

          <p class=req id=H30730><span>The pages in an index B-Tree structures are arranged into a tree
structure such that all leaf pages are at the same depth.</span></p>
          <p class=req id=H30740><span>Each leaf node page in an index B-Tree contains one or more
B-Tree cells, where each cell contains a database record.</span></p>
          <p class=req id=H30750><span>Each internal node page in an index B-Tree contains one or more
B-Tree cells, where each cell contains a child page number, <i>C</i>,
and a database record <i>R</i>. All database records stored within
the sub-tree headed by page <i>C</i> are smaller than record <i>R</i>,
according to the index sort order (see below). Additionally, unless
<i>R</i> is the smallest database record stored on the internal node
page, all integer keys within the sub-tree headed by <i>C</i> are
greater than <i>R<sub>-1</sub></i>, where <i>R<sub>-1</sub></i> is the
largest database record on the internal node page that is smaller
than <i>R</i>.</span></p>
          <p class=req id=H30760><span>As well as child page numbers associated with B-Tree cells, each
internal node page in an index B-Tree contains the page number
of an extra child page, the <i>right-child page</i>. All database
records stored in all B-Tree cells within the sub-tree headed by the
<i>right-child page</i> are greater than all database records
stored within B-Tree cells on the internal node page.</span></p>

      <p>
        The precise way in which index B-Tree pages and cells are formatted is
        described in subsequent sections.


        <h4 id="section_2_3_3_1">2.3.3.1 Index B-Tree Content</h4>

          <p>
            The <a class=defnlink href="#glossary_Database_file">database file</a> contains one index B-Tree for each database index
            in the logical database, including those created by UNIQUE or
            PRIMARY KEY clauses in table declarations. Each record stored in
            an index B-Tree contains the same number of fields, the number of
            indexed columns in the database index declaration plus one. 
          <p>
            An index B-Tree contains an entry for each row in its associated
            database table. The fields of the record used as the index B-Tree
            key are copies of each of the indexed columns of the associated 
            database row, in order, followed by the rowid value of the same 
            row. See figure <cite><a href="#figure_examplepop" title="Example B-Tree Data">1</a></cite> for an example.

          <p class=req id=H30770><span>In a well-formed database, each index B-Tree contains a single entry
for each row in the indexed logical database table.</span></p>
          <p class=req id=H30780><span>Each <i>database record</i> (key) stored by an index B-Tree in a
well-formed database contains the same number of values, the number
of indexed columns plus one.</span></p>
          <p class=req id=H30790><span>The final value in each <i>database record</i> (key) stored by an
index B-Tree in a well-formed database contains the rowid (an integer
value) of the corresponding logical database row.</span></p>
          <p class=req id=H30800><span>The first <i>N</i> values in each <i>database record</i> (key)
stored in an index B-Tree where <i>N</i> is the number of indexed
columns, contain the values of the indexed columns from the
corresponding logical database row, in the order specified for the
index.</span></p>
 
      <h4 id="index_btree_compare_func">2.3.3.2 Record Sort Order</h4>

        <p>
          This section defines the comparison function used when database
          records are used as B-Tree keys for index B-Trees. The comparison
          function is only defined when both database records contain the same
          number of fields.
        <p>
          When comparing two database records, the first field of one
          record is compared to the first field of the other. If they
          are not equal, the next pair of fields are compared, and so
          on. If all the fields in the database records are equal, then
          the two records are considered equal. Otherwise, the result
          of the comparison is determined by the first pair of inequal 
          fields.
        <p>
          Two database record fields (SQL values) are compared using the
          following rules:
        <ol>
          <li>If both values are NULL, then they are considered equal.
          <li>If one value is a NULL and the other is not, it is considered
              the lesser of the two.
          <li>If both values are either real or integer values, then the
              comparison is done numerically.
          <li>If one value is a real or integer value, and the other is
              a text or blob value, then the numeric value is considered 
              lesser.
          <li>If both values are text, then the collation function is used
              to compare them. The collation function is a property of the
              index column in which the values are found. <span class=todo>
              Link to document with CREATE INDEX syntax.</span>
          <li>If one value is text and the other a blob, the text value
              is considered lesser.
          <li>If both values are blobs, memcmp() is used to determine the 
              results of the comparison function. If one blob is a prefix
              of the other, the shorter blob is considered lesser.
        </ol>
        <p>
          Each column of a database index may be declared as "descending".
          <span class=todo>Link to document with CREATE INDEX syntax.</span>
          In SQLite <a class=defnlink href="#glossary_Database_file">database files</a> with a schema layer file-format equal
          to 4, this modifies the order in which the records are stored in
          the corresponding index B-Tree structure. For each index column
          declared as descending, the results of the above comparison 
          procedure are inverted.
        <p>
          The columns of database indexes created by UNIQUE or PRIMARY
          KEY clauses are never treated as descending.

        <p class=todo>
          Need requirements style statements for this information. Easier
          to do once collation sequences have been defined somewhere.


      <h4 id="index_btree_page_format">2.3.3.3 Index B-Tree Page Format</h4>

        <p>
          Each index B-Tree page is divided into four sections that occur
          in order on the page:
        <ul>
          <li> The 8-byte (leaf node pages) or 12-byte (internal tree
               node pages) page-header.
          <li> The cell offset array. This is a series of N big-endian 2-byte
               integer values, where N is the number of records stored on 
               the page.
          <li> A block of unused space. This may be 0 bytes in size.
          <li> The cell content area consumes the remaining space on the page.
        </ul>
        
      <center>
      <a name="figure_indexpage"></a>
      <img src="images/fileformat/indexpage.gif">
      <p><i>Figure 4 - Index B-Tree Page Data</i>
      </center>
  
        <p>
          The 8-byte (leaf node pages) or 12-byte (internal tree node pages)
          page header that begins each index B-Tree page is made up
          of a series of 
          1, 2 and 4 byte unsigned integer values as shown in the following
          table. All values are stored in big-endian byte order.

      <table style="margin:1em auto;width:80%;border-spacing:0">
        <tr style="text-align:left"><th>Byte Range <th>Byte Size <th width=100%>Description
        <tr style="text-align:left;background-color:#DDDDDD"><td>0     <td>1<td>B-Tree page flags. For an index B-Tree internal 
                               tree node page, this is set to 0x02. For a
                               leaf node page, 0x0A.
        <tr style="text-align:left"><td>1..2  <td>2<td>Byte offset of first block of free space on 
                               this page. If there are no free blocks on this
                               page, this field is set to 0.
        <tr style="text-align:left;background-color:#DDDDDD"><td>3..4  <td>2<td>Number of cells (entries) on this page.
        <tr style="text-align:left"><td>5..6  <td>2<td>Byte offset of the first byte of the cell
                               content area (see figure 
                               <cite><a href="#figure_indexpage" title="Index B-Tree Page Data">4</a></cite>), relative to the 
                               start of the page.
        <tr style="text-align:left;background-color:#DDDDDD"><td>7     <td>1<td>Number of fragmented free bytes on page.
        <tr style="text-align:left"><td>8..11 <td>4<td>Page number of rightmost child-page (the
                               child-page that heads the sub-tree in which all
                               records are larger than all records stored on
                               this page). This field is not present for leaf
                               node pages.
      </table>
      <p>
        The cell content area, which occurs last on the page, contains one
        B-Tree cell for each record stored on the B-Tree page. On a leaf node
        page, each cell is responsible for storing a database record only. On
        an internal tree node page, each cell contains a database record and
        the corresponding child page number ((R(0) and C(0)) are stored 
        together, for example - the cell record is considered greater than
        all records stored in the sub-tree headed by the child page). The
        final child page number is stored as part of the page header.
      <p>
        The B-Tree cells may be distributed throughout the cell content area
        and may be interspersed with blocks of unused space. They are not
        sorted within the cell content area in any particular order. The
        serialized format of a B-Tree cell is described in detail in 
        section <cite><a href="#index_btree_cell_format" title="Index B-Tree Cell Format">2.3.3.4</a></cite>.
      <p>
        The byte offset of each cell in the cell content area, relative
        to the start of the page, is stored in the cell offset array. The
        offsets are in sorted order according to the database records stored
        in the corresponding cells. The first offset in the array is the 
        offset of the cell containing the smallest record on the page,
        according to the comparison function defined in section 
        <cite><a href="#index_btree_compare_func" title="Record Sort Order">2.3.3.2</a></cite>.
      <p>
        As well as the block of unused space between the cell offset array and
        the cell content area, which may be any size, there may be small blocks
        of free space interspersed with the B-Tree cells within the cell
        content area. These are classified into two classes, depending on their
        size:
      <ul>
        <li>Blocks of free-space consisting of 3 bytes or less are called
            <b>fragments</b>. The total number of bytes consumed by all
            fragments on a page is stored in the 1 byte unsigned integer at
            byte offset 7 of the page header. The total number of fragmented
            bytes on a single page is never greater than 255.
        <li>Blocks of free-space consisting of more than 3 bytes of contiguous
            space are called <b>free blocks</b>. All free blocks on a single
            page are linked together into a singly linked list. The byte
            offset (relative to the start of the page) of the first block in 
            the list is stored in the 2 byte unsigned integer stored at byte
            offset 1 of the page header. The first two bytes of each free
            block contain the byte offset (again relative to the start of
            the page) of the next block in the list stored as a big-endian
            unsigned integer. The first two bytes of the final block in the 
            list are set to zero. The third and fourth bytes of each free
            block contain the total size of the free block in bytes, stored
            as a 2 byte big-endian unsigned integer.
      </ul>

      <p class=todo>
	The list of free blocks is kept in order, sorted by offset. Right?
	Later: True statement. SQLite function sqlite3BtreeInitPage() returns
        SQLITE_CORRUPT if they are not.

          <p class=req id=H30810><span>The <i>b-tree page flags</i> field (the first byte) of each database
page used as an internal node of an index B-Tree structure is set to
0x02.</span></p>
          <p class=req id=H30820><span>The <i>b-tree page flags</i> field (the first byte) of each database
page used as a leaf node of an index B-Tree structure is set to 0x0A.</span></p>

      <p>
        The following requirements describe the <i>B-Tree page header</i>
        present at the start of both index and table B-Tree pages.

          <p class=req id=H30830><span>The first byte of each database page used as a B-Tree page contains
the <i>b-tree page flags</i> field. On page 1, the <i>b-tree page
flags</i> field is stored directly after the 100 byte file header
at byte offset 100.</span></p>
          <p class=req id=H30840><span>The number of B-Tree cells stored on a B-Tree page is stored as a
2-byte big-endian integer starting at byte offset 3 of the B-Tree
page. On page 1, this field is stored at byte offset 103.</span></p>
          <p class=req id=H30850><span>The 2-byte big-endian integer starting at byte offset 5 of each
B-Tree page contains the byte-offset from the start of the page
to the start of the <i>cell content area</i>, which consumes all space
from this offset to the end of the usable region of the page.
On page 1, this field is stored at byte offset 105.  All B-Tree
cells on the page are stored within the cell-content area.</span></p>
          <p class=req id=H30860><span>On each page used as an internal node a of B-Tree structures, the
page number of the rightmost child node in the B-Tree structure is
stored as a 4-byte big-endian unsigned integer beginning at byte
offset 8 of the database page, or byte offset 108 on page 1.</span></p>

      <p>
        This requirement describes the cell content offset array. It applies
        to both B-Tree variants.

          <p class=req id=H30870><span>Immediately following the <i>page header</i> on each B-Tree page is the
<i>cell offset array</i>, consisting of <i>N</i> 2-byte big-endian
unsigned integers, where <i>N</i> is the number of cells stored
on the B-Tree page (<a class=reqlink href=#H30840>H30840</a>). On an internal node B-Tree page,
the cell offset array begins at byte offset 12, or on a leaf
page, byte offset 8. For the B-Tree node on page 1, these
offsets are 112 and 108, respectively.</span></p>
          <p class=req id=H30880><span>The <i>cell offset array</i> and the <i>cell content area</i> (<a class=reqlink href=#H30850>H30850</a>)
may not overlap.</span></p>
          <p class=req id=H30890><span>Each value stored in the <i>cell offset array</i> must be greater
than or equal to the offset to the <i>cell content area</i> (<a class=reqlink href=#H30850>H30850</a>),
and less than the database <i><a class=defnlink href="#glossary_Page_size">page size</a></i>.</span></p>
          <p class=req id=H30900><span>The <i>N</i> values stored within the <i>cell offset array</i> are the
byte offsets from the start of the B-Tree page to the beginning of
each of the <i>N</i> cells stored on the page.</span></p>
          <p class=req id=H30910><span>No two B-Tree cells may overlap.</span></p>

      <p>
        The following requirements govern management of free-space within the
        page content area (both table and index B-Tree pages).

          <p class=req id=H30920><span>Within the <i>cell content area</i>, all blocks of contiguous
free-space (space not used by B-Tree cells) greater than 3 bytes in
size are linked together into a linked list, the <i>free block list</i>.
Such blocks of free space are known as <i>free blocks</i>.</span></p>
          <p class=req id=H30930><span>The first two bytes of each <i>free block</i> contain the offset
of the next <i>free block</i> in the <i>free block list</i> formatted
as a 2-byte big-endian integer, relative to the start of the database
page. If there is no next <i>free block</i>, then the first two
bytes are set to 0x00.</span></p>
          <p class=req id=H30940><span>The second two bytes (byte offsets 2 and 3) of each <i>free block</i>
contain the total size of the <i>free block</i>, formatted as a 2-byte
big-endian integer.</span></p>
          <p class=req id=H30950><span>On all B-Tree pages, the offset of the first <i>free block</i> in the
<i>free block list</i>, relative to the start of the database page,
is stored as a 2-byte big-endian integer starting at byte offset
1 of the database page. If there is no first <i>free block</i>
(because the <i>free block list</i> is empty), then the two bytes
at offsets 1 and 2 of the database page are set to 0x00. On page 1,
this field is stored at byte offset 101 of the page.</span></p>
          <p class=req id=H30960><span>Within the cell-content area, all blocks of contiguous free-space
(space not used by B-Tree cells) less than or equal to 3 bytes in
size are known as <i>fragments</i>. The total size of all
<i>fragments</i> on a B-Tree page is stored as a 1-byte unsigned
integer at byte offset 7 of the database page. On page 1, this
field is stored at byte offset 107.</span></p>

      <h4 id="index_btree_cell_format">2.3.3.4 Index B-Tree Cell Format</h4>

        <p> 
          For index B-Tree internal tree node pages, each B-Tree cell begins
          with a child page-number, stored as a 4-byte big-endian unsigned
          integer. This field is omitted for leaf pages, which have no 
          children.
        <p> 
          Following the child page number is the total number of bytes 
          consumed by the cell's record, stored as a variable length integer
          (see section <cite><a href="#varint_format" title="Variable Length Integer Format">2.3.1</a></cite>). 
        <p> 
          If the record is small enough, it is stored verbatim in the cell.
          A record is deemed to be small enough to be completely stored in
          the cell if it consists of less than or equal to:
        <pre>
            <i>max-local</i> := (<i>usable-size</i> - 12) * <i>max-embedded-fraction</i> / 255 - 23
</pre>
        <p>
          bytes. In the formula above, <i>usable-size</i> is the <a class=defnlink href="#glossary_Page_size">page-size</a>
          in bytes less the number of unused bytes left at the end of every
          page (as read from byte offset 20 of the <a class=defnlink href="#glossary_Database_header">database header</a>), and
          <i>max-embedded-fraction</i> is the value read from byte offset 
          21 of the <a class=defnlink href="#glossary_Database_header">database header</a>.
        
      <center>
      <a name="figure_indexshortrecord"></a>
      <img src="images/fileformat/indexshortrecord.gif">
      <p><i>Figure 5 - Small Record Index B-Tree Cell</i>
      </center>
  
        <p>
          If the cell record is larger than the maximum size identified by
          the formula above, then only the first part of the record is stored
          within the cell. The remainder is stored in an overflow-chain (see
          section <cite><a href="#overflow_page_chains" title="Overflow Page Chains">2.3.5</a></cite> for details). Following 
          the part of the record stored within the cell is the page number 
          of the first page in the overflow chain, stored as a 4 byte 
          big-endian unsigned integer. The size of the part of the record 
          stored within the B-Tree cell (<i>local-size</i> in figure 
          <cite><a href="#figure_indexlongrecord" title="Large Record Index B-Tree Cell">6</a></cite>) is calculated according to the 
          following algorithm:
        <pre>
            <i>min-local</i> := (<i>usable-size</i> - 12) * <i>min-embedded-fraction</i> / 255 - 23
            <i>max-local</i> := (<i>usable-size</i> - 12) * <i>max-embedded-fraction</i> / 255 - 23
            <i>local-size</i> := <i>min-local</i> + (<i>record-size</i> - <i>min-local</i>) % (<i>usable-size</i> - 4)
            if( <i>local-size</i> &gt; <i>max-local</i> )
                <i>local-size</i> := <i>min-local</i>
</pre>
        <p>
          In the formula above, <i>usable-size</i> is the <a class=defnlink href="#glossary_Page_size">page-size</a>
          in bytes less the number of unused bytes left at the end of every
          page (as read from byte offset 20 of the <a class=defnlink href="#glossary_Database_header">database header</a>), and
          <i>max-embedded-fraction</i> and <i>min-embedded-fraction</i> are
          the values read from byte offsets 21 and 22 of the <a class=defnlink href="#glossary_Database_header">database header</a>,
          respectively.
        
      <center>
      <a name="figure_indexlongrecord"></a>
      <img src="images/fileformat/indexlongrecord.gif">
      <p><i>Figure 6 - Large Record Index B-Tree Cell</i>
      </center>
  

          <p class=req id=H30970><span>Each B-Tree cell belonging to an internal node page of an index
B-Tree consists of a 4-byte big-endian unsigned integer, the
<i>child page number</i>, followed by a <i>variable length integer</i>
field, followed by a <i>database record</i>. The
<i>variable length integer</i> field contains the length of the
database record in bytes.</span></p>
          <p class=req id=H30980><span>Each B-Tree cell belonging to an leaf page of an index B-Tree
consists of a <i>variable length integer</i> field, followed by
a <i>database record</i>. The <i>variable length integer</i> field
contains the length of the database record in bytes.</span></p>
          <p class=req id=H30990><span>If the database record stored in an index B-Tree page is
sufficiently small, then the entire cell is stored within the
index B-Tree page.  Sufficiently small is defined as equal to or
less than <i>max-local</i>, where:
<code>
<i>max-local</i> := (<i>usable-size</i> - 12) * 64 / 255 - 23</code></span></p>
          <p class=req id=H31000><span>If the database record stored as part of an index B-Tree cell is too
large to be stored entirely within the B-Tree page (as defined by
<a class=reqlink href=#H30520>H30520</a>), then only a prefix of the <i>database record</i> is stored
within the B-Tree page and the remainder stored in an <i>overflow
chain</i>. In this case, the database record prefix is immediately
followed by the page number of the first page of the
<i>overflow chain</i>, formatted as a 4-byte big-endian unsigned
integer.</span></p>
          <p class=req id=H31010><span>When a <i>database record</i> belonging to a table B-Tree cell is
stored partially within an <i>overflow page chain</i>, the size
of the prefix stored within the index B-Tree page is <i>N</i> bytes,
where <i>N</i> is calculated using the following algorithm:
<code>
<i>min-local</i> := (<i>usable-size</i> - 12) * 32 / 255 - 23
<i>max-local</i> := (<i>usable-size</i> - 12) * 64 / 255 - 23
<i>N</i> := <i>min-local</i> + ((<i>record-size</i> - <i>min-local</i>) % (<i>usable-size</i> - 4))
if( <i>N</i> &gt; <i>max-local</i> ) <i>N</i> := <i>min-local</i></code></span></p>

      <p>
        Requirements <a class=reqlink href=#H31010>H31010</a> and <a class=reqlink href=#H30990>H30990</a> are similar to the algorithms 
        presented in the text above. However instead of 
        <i>min-embedded-fraction</i> and <i>max-embedded-fraction</i> the
        requirements use the constant values 32 and 64, as well-formed 
        <a class=defnlink href="#glossary_Database_file">database files</a> are required by H30080 and H30070 to store these 
        values in the relevant database <a class=defnlink href="#glossary_Database_header">database header</a> fields.

    <h3 id="table_btrees">2.3.4 Table B-Trees</h3>

      <p>
        As noted in section <cite><a href="#fileformat_overview" title="Image Format Overview">2.1</a></cite>, table B-Trees
        store a set of unique 64-bit signed integer keys. Associated with
        each key is a database record. As with index B-Trees, the <a class=defnlink href="#glossary_Database_file">database
        file</a> pages that make up a table B-Tree are organized into a tree
        structure with a single "root" page at the head of the tree.
      <p>
        Unlike index B-Tree structures, where entries are stored on both
        internal and leaf nodes, all entries in a table B-Tree are stored
        in the leaf nodes. Within each leaf node, keys are stored in sorted
        order.
      <p>
        Each internal tree node contains an ordered list of N references 
        to child pages, where N is some number greater than one. In a 
        similar manner to the way in which an index B-Tree page would 
        contain N-1 records, each internal table B-Tree node page also 
        contains a list of N-1 64-bit signed integer values in sorted order. 
        The keys are distributed throughout the tree such that for all internal
        tree nodes, integer I(n) is equal to the largest key value stored in
        the sub-tree headed by child page C(n) for values of n between 0 and
        N-2, inclusive. Additionally, all keys stored in the sub-tree headed
        by child page C(n+1) have values larger than that of I(n), for values
        of n in the same range.

        
      <center>
      <a name="figure_tabletree"></a>
      <img src="images/fileformat/tabletree.gif">
      <p><i>Figure 7 - Table B-Tree Tree Structure</i>
      </center>
  

      <p>
        Figure <cite><a href="#figure_tabletree" title="Table B-Tree Tree Structure">7</a></cite> depicts a table B-Tree containing
        a contiguous set of 14 integer keys starting with 1. Each key <i>n</i>
        has an associated database record R<i>n</i>. All the keys and their
        associated records are stored in the leaf pages. The internal node
        pages contain no database data, their only purpose is to provide
        a way to navigate the tree structure.

          <p class=req id=H31020><span>The pages in a table B-Tree structures are arranged into a tree
structure such that all leaf pages are at the same depth.</span></p>
          <p class=req id=H31030><span>Each leaf page in a table B-Tree structure contains one or more
B-Tree cells, where each cell contains a 64-bit signed integer key
value and a database record.</span></p>
          <p class=req id=H31040><span>Each internal node page in a table B-Tree structure contains one or
more B-Tree cells, where each cell contains a 64-bit signed integer
key value, <i>K</i>, and a child page number, <i>C</i>. All integer key
values in all B-Tree cells within the sub-tree headed by page <i>C</i>
are less than or equal to <i>K</i>. Additionally, unless <i>K</i>
is the smallest integer key value stored on the internal node page,
all integer keys within the sub-tree headed by <i>C</i> are greater
than <i>K<sub>-1</sub></i>, where <i>K<sub>-1</sub></i> is the largest
integer key on the internal node page that is smaller than <i>K</i>.</span></p>
          <p class=req id=H31050><span>As well as child page numbers associated with B-Tree cells, each
internal node page in a table B-Tree contains the page number
of an extra child page, the <i>right-child page</i>. All key values
in all B-Tree cells within the sub-tree headed by the <i>right-child
page</i> are greater than all key values stored within B-Tree cells
on the internal node page.</span></p>

      <p class=todo>
        The special case for root page 1. Root page 1 may contain zero cells,
        just a right-child pointer to the only other b-tree page in the tree.

      <p>
        The precise way in which table B-Tree pages and cells are formatted is
        described in subsequent sections.

      <h4 id="table_btree_content">2.3.4.1 Table B-Tree Content</h4>

        <p>
          The <a class=defnlink href="#glossary_Database_file">database file</a> contains one table B-Tree for each database table
          in the logical database. Although some data may be duplicated in
          index B-Tree structures, the table B-Tree is the primary location
          of table data.
        <p>
          The table B-Tree contains exactly one entry for each row in the
          database table. The integer key value used for the B-Tree entry is
          the value of the "rowid" field of the corresponding logical row 
          in the database table. The database row fields are stored in the
          record associated with the table B-Tree entry, in the same order
          as they appear in the logical database table. The first field in
          the record (see section <cite><a href="#record_format" title="Database Record Format">2.3.2</a></cite>) contains the
          value of the leftmost field in the database row, and so on.
        <p>
          If a database table column is declared as an INTEGER PRIMARY KEY,
          then it is an alias for the rowid field, which is stored as the 
          table B-Tree key value. Instead of duplicating the integer value
          in the associated record, the record field associated with the
          INTEGER PRIMARY KEY column is always set to an SQL NULL.
        <p>
          Finally, if the schema layer file-format is greater than or equal 
          to 2, some of the records stored in table B-Trees may contain
          less fields than the associated logical database table does columns.
          If the schema layer file-format is exactly 2, then the logical
          database table column values associated with the "missing" fields 
          are SQL NULL. If the schema layer file-format is greater than
          2, then the values associated with the "missing" fields are 
          determined by the default value of the associated database table 
          columns.
          <span class=todo>Reference to CREATE TABLE syntax. How are default
          values determined?</span>

          <p class=req id=H31060><span>In a well-formed database, each table B-Tree contains a single entry
for each row in the corresponding logical database table.</span></p>
          <p class=req id=H31070><span>The key value (a 64-bit signed integer) for each B-Tree entry is
the same as the value of the rowid field of the corresponding
logical database row.</span></p>
          <p class=req id=H31080><span>The SQL values serialized to make up each <i>database record</i>
stored as ancillary data in a table B-Tree shall be the equal to the
values taken by the <i>N</i> leftmost columns of the corresponding
logical database row, where <i>N</i> is the number of values in the
database record.</span></p>
          <p class=req id=H31090><span>If a logical database table column is declared as an "INTEGER
PRIMARY KEY", then instead of its integer value, an SQL NULL
shall be stored in its place in any database records used as
ancillary data in a table B-Tree.</span></p>

        <p>The following database properties discuss table B-Tree records 
           with implicit (default) values.

          <p class=req id=H31100><span>If the database <i>schema layer file-format</i> (the value stored
as a 4-byte integer at byte offset 44 of the file header) is 1,
then all database records stored as ancillary data in a table
B-Tree structure have the same number of fields as there are
columns in the corresponding logical database table.</span></p>
          <p class=req id=H31110><span>If the database <i>schema layer file-format</i> value is two or
greater and the rightmost <i>M</i> columns of a row contain SQL NULL
values, then the corresponding record stored as ancillary data in
the table B-Tree has between <i>N</i>-<i>M</i> and <i>N</i> fields,
where <i>N</i> is the number of columns in the logical database
table.</span></p>
          <p class=req id=H31120><span>If the database <i>schema layer file-format</i> value is three or
greater and the rightmost <i>M</i> columns of a row contain their
default values according to the logical table declaration, then the
corresponding record stored as ancillary data in the table B-Tree
may have as few as <i>N</i>-<i>M</i> fields, where <i>N</i> is the
number of columns in the logical database table.</span></p>

      <h4 id="section_2_3_4_2">2.3.4.2 Table B-Tree Page Format</h4>

        <p>
          Table B-Tree structures use the same page format as index B-Tree 
          structures, described in section <cite><a href="#index_btree_page_format" title="Index B-Tree Page Format">2.3.3.3</a></cite>,
          with the following differences:
        <ul>
          <li>The first byte of the page-header, the "flags" field, is set to 
              0x05 for internal tree node pages, and 0x0D for leaf pages.
          <li>The content and format of the B-Tree cells is different. See
              section <cite><a href="#table_btree_cell_format" title="Table B-Tree Cell Format">2.3.4.3</a></cite> for details.
          <li>The format of page 1 is the same as any other table B-Tree,
              except that 100 bytes less than usual is available for content.
              The first 100 bytes of page 1 is consumed by the <a class=defnlink href="#glossary_Database_header">database
              header</a>.
        </ul>

          <p class=req id=H31130><span>In a <i>well-formed <a class=defnlink href="#glossary_Database_file">database file</a></i>, the first byte of each page used
as an internal node of a table B-Tree structure is set to 0x05.</span></p>
          <p class=req id=H31140><span>In a <i>well-formed <a class=defnlink href="#glossary_Database_file">database file</a></i>, the first byte of each page used
as a leaf node of a table B-Tree structure is set to 0x0D.</span></p>
        
      <p>
        Most of the requirements specified in section 
        <cite><a href="#index_btree_page_format" title="Index B-Tree Page Format">2.3.3.3</a></cite> also apply to table B-Tree 
        pages. The wording of the requirements make it clear when this is
        the case, either by referring to generic "B-Tree pages" or by
        explicitly stating that the statement applies to both "table and
        index B-Tree pages".

      <h4 id="table_btree_cell_format">2.3.4.3 Table B-Tree Cell Format</h4>

        <p>
          Cells stored on internal table B-Tree nodes consist of exactly two 
          fields. The associated child page number, stored as a 4-byte
          big-endian unsigned integer, followed by the 64-bit signed integer
          value, stored as a variable length integer (section 
          <cite><a href="#varint_format" title="Variable Length Integer Format">2.3.1</a></cite>). This is depicted graphically in figure
          <cite><a href="#figure_tablenodecell" title="Table B-Tree Internal Node Cell">8</a></cite>.
        
      <center>
      <a name="figure_tablenodecell"></a>
      <img src="images/fileformat/tablenodecell.gif">
      <p><i>Figure 8 - Table B-Tree Internal Node Cell</i>
      </center>
  
        <p>
          Cells of table B-Tree leaf pages are required to store a 64-bit
          signed integer key and its associated database record. The first
          two fields of all table B-Tree leaf page cells are the size of
          the database record, stored as a <i>variable length integer</i>
          (see section <cite><a href="#varint_format" title="Variable Length Integer Format">2.3.1</a></cite>), followed by the key
          value, also stored as a <i>variable length integer</i>. For 
          sufficiently small records, the entire record is stored in the 
          B-Tree cell following the record-size field. In this case, 
          sufficiently small is defined as less than or equal to:
        <pre>
          max-local := <i>usable-size</i> - 35
</pre>
        <p>
          bytes. Where <i>usable-size</i> is defined as the <a class=defnlink href="#glossary_Page_size">page-size</a>
          in bytes less the number of unused bytes left at the end of every
          page (as read from byte offset 20 of the <a class=defnlink href="#glossary_Database_header">database header</a>). 
          This scenario, where the entire record is
          stored within the B-Tree cell, is depicted in figure
          <cite><a href="#figure_tableshortrecord" title="Table B-Tree Small Record Leaf Node Cell">9</a></cite>.
        
      <center>
      <a name="figure_tableshortrecord"></a>
      <img src="images/fileformat/tableshortrecord.gif">
      <p><i>Figure 9 - Table B-Tree Small Record Leaf Node Cell</i>
      </center>
  

        <p>
          If the record is too large to be stored entirely within the B-Tree
          cell, then the first part of it is stored within the cell and the
          remainder in an overflow chain (see section
          <cite><a href="#overflow_page_chains" title="Overflow Page Chains">2.3.5</a></cite>). The size of the part of the 
          record stored within the B-Tree cell (<i>local-size</i> in figure
          <cite><a href="#figure_tablelongrecord" title="Table B-Tree Large Record Leaf Node Cell">10</a></cite>) is calculated according to
          the following algorithm (a similar procedure to that used to
          calculate the portion of an index B-Tree key to store within the cell
          when an overflow chain is required):
        <pre>
            <i>min-local</i> := (<i>usable-size</i> - 12) * <i>min-embedded-fraction</i> / 255 - 23
            <i>max-local</i> := <i>usable-size</i> - 35
            <i>local-size</i> := <i>min-local</i> + (<i>record-size</i> - <i>min-local</i>) % (<i>usable-size</i> - 4)
            if( <i>local-size</i> &gt; <i>max-local</i> )
                <i>local-size</i> := <i>min-local</i>
</pre>
        <p>
          In this case, <i>min-embedded-fraction</i> is the value read from
          byte offset 22 of the <a class=defnlink href="#glossary_Database_header">database header</a>. The layout of the cell in this
          case, when an overflow-chain is required, is shown in figure
          <cite><a href="#figure_tablelongrecord" title="Table B-Tree Large Record Leaf Node Cell">10</a></cite>.

        
      <center>
      <a name="figure_tablelongrecord"></a>
      <img src="images/fileformat/tablelongrecord.gif">
      <p><i>Figure 10 - Table B-Tree Large Record Leaf Node Cell</i>
      </center>
  

        <p>
          If the leaf page is page 1, then the value of <i>usable-size</i> is
          as it would be for any other B-Tree page, even though the actual
          usable size is 100 bytes less than this for page 1 (because the
          first 100 bytes of the page is consumed by the <a class=defnlink href="#glossary_Database_file">database file</a>
          header).

        <p>
          The following requirements describe the format of table B-Tree 
          cells, and the distribution thereof between B-Tree and overflow
          pages.

          <p class=req id=H31150><span>B-Tree cells belonging to table B-Tree internal node pages consist
of exactly two fields, a 4-byte big-endian unsigned integer
immediately followed by a <i>variable length integer</i>. These
fields contain the child page number and key value respectively
(see <a class=reqlink href=#H31030>H31030</a>).</span></p>
          <p class=req id=H31160><span>B-Tree cells belonging to table B-Tree leaf node pages consist
of three fields, two <i>variable length integer</i> values
followed by a database record. The size of the database record
in bytes is stored in the first of the two
<i>variable length integer</i> fields. The second of the two
<i>variable length integer</i> fields contains the 64-bit signed
integer key (see <a class=reqlink href=#H31030>H31030</a>).</span></p>
          <p class=req id=H31170><span>If the size of the record stored in a table B-Tree leaf page cell
is less than or equal to (<i>usable <a class=defnlink href="#glossary_Page_size">page size</a></i>-35) bytes, then
the entire cell is stored on the B-Tree leaf page. In a well-formed
database, <i>usable <a class=defnlink href="#glossary_Page_size">page size</a></i> is the same as the database
<i><a class=defnlink href="#glossary_Page_size">page size</a></i>.</span></p>
          <p class=req id=H31180><span>If a table B-Tree cell is too large to be stored entirely on
a leaf page (as defined by <a class=reqlink href=#H31170>H31170</a>), then a prefix of the cell
is stored on the leaf page, and the remainder stored in an
<i>overflow page chain</i>. In this case the cell prefix
stored on the B-Tree leaf page is immediately followed by a
4-byte big-endian unsigned integer containing the page number
of the first overflow page in the chain.</span></p>
          <p class=req id=H31190><span>When a table B-Tree cell is stored partially in an
<i>overflow page chain</i>, the prefix stored on the B-Tree
leaf page consists of the two <i>variable length integer</i> fields,
followed by the first <i>N</i> bytes of the database record, where
<i>N</i> is determined by the following algorithm:
<code>
<i>min-local</i> := (<i>usable-size</i> - 12) * 32 / 255 - 23
<i>max-local</i> := (<i>usable-size</i> - 35)
<i>N</i> := <i>min-local</i> + (<i>record-size</i> - <i>min-local</i>) % (<i>usable-size</i> - 4)
if( <i>N</i> &gt; <i>max-local</i> ) N := <i>min-local</i>
</code></span></p>
        
        <p>
          Requirement <a class=reqlink href=#H31190>H31190</a> is very similar to the algorithm presented in
          the text above. Instead of <i>min-embedded-fraction</i>, it uses
          the constant value 32, as well-formed <a class=defnlink href="#glossary_Database_file">database files</a> are required
          by H30090 to store this value in the relevant <a class=defnlink href="#glossary_Database_file">database file</a> 
          header field.

    <h3 id="overflow_page_chains">2.3.5 Overflow Page Chains</h3>

      <p>
        Sometimes, a database record stored in either an index or table 
        B-Trees is too large to fit entirely within a B-Tree cell. In this
        case part of the record is stored within the B-Tree cell and the
        remainder stored on one or more overflow pages. The overflow pages
        are chained together using a singly linked list. The first 4 bytes
        of each overflow page is a big-endian unsigned integer value 
        containing the page number of the next page in the list. The 
        remaining usable database page space is available for record data.

        
      <center>
      <a name="figure_overflowpage"></a>
      <img src="images/fileformat/overflowpage.gif">
      <p><i>Figure 11 - Overflow Page Format</i>
      </center>
  

      <p>
        The scenarios in which overflow pages are required and the number
        of bytes stored within the B-Tree cell in each are described for
        index and table B-Trees in sections 
        <cite><a href="#index_btree_cell_format" title="Index B-Tree Cell Format">2.3.3.4</a></cite> and
        <cite><a href="#table_btree_cell_format" title="Table B-Tree Cell Format">2.3.4.3</a></cite> respectively. In each case 
        the B-Tree cell also stores the page number of the first page in
        a linked list of overflow pages.
      <p>
        The amount of space available for record data on each overflow 
        page is:
      <pre>
        <i>available-space</i> := <i>usable-size</i> - 4
</pre>
      <p>
        Where <i>usable-size</i> is defined as the <a class=defnlink href="#glossary_Page_size">page-size</a> in bytes less the
        number of unused bytes left at the end of every page (as read from 
        byte offset 20 of the <a class=defnlink href="#glossary_Database_header">database header</a>).
      <p>
        Each overflow page except for the last one in the linked list 
        contains <i>available-space</i> bytes of record data. The last
        page in the list contains the remaining data, starting at byte
        offset 4. The value of the "next page" field on the last page
        in an overflow chain is undefined.

          <p class=req id=H31200><span>A single <i>overflow page</i> may store up to <i>available-space</i>
bytes of database record data, where <i>available-space</i> is equal
to (<i>usable-size</i> - 4).</span></p>
          <p class=req id=H31210><span>When a database record is too large to store within a B-Tree page
(see <a class=reqlink href=#H31170>H31170</a> and <a class=reqlink href=#H31000>H31000</a>), a prefix of the record is stored within
the B-Tree page and the remainder stored across <i>N</i> overflow
pages. In this case <i>N</i> is the minimum number of pages required
to store the portion of the record not stored on the B-Tree page,
given the maximum payload per overflow page defined by <a class=reqlink href=#H31200>H31200</a>.</span></p>
          <p class=req id=H31220><span>The list of overflow pages used to store a single database record
are linked together in a singly linked list known as an
<i>overflow chain</i>. The first four bytes of each page except the
last in an <i>overflow chain</i> are used to store the page number
of the next page in the linked list, formatted as an unsigned
big-endian integer. The first four bytes of the last page in an
<i>overflow chain</i> are set to 0x00.</span></p>
          <p class=req id=H31230><span>Each overflow page except the last in an <i>overflow chain</i>
contains <i>N</i> bytes of record data starting at byte offset 4 of
the page, where <i>N</i> is the maximum payload per overflow page,
as defined by <a class=reqlink href=#H31200>H31200</a>. The final page in an <i>overflow chain</i>
contains the remaining data, also starting at byte offset 4.</span></p>

  <h2 id="free_page_list">2.4 The Free Page List</h2>

    <p>
      Sometimes, after deleting data from the database, SQLite removes pages
      from B-Tree structures. If these pages are not immediately required
      for some other purpose, they are placed on the free page list. The
      free page list contains those pages that are not currently being
      used to store any valid data.
    <p>
      Each page in the free-list is classified as a free-list trunk page 
      or a free-list leaf page. All trunk pages are linked together into
      a singly linked list (in the same way as pages in an overflow chain
      are - see section <cite><a href="#overflow_page_chains" title="Overflow Page Chains">2.3.5</a></cite>). The first four
      bytes of each trunk page contain the page number of the next trunk
      page in the list, formatted as an unsigned big-endian integer. If
      the trunk page is the last page in the linked list, the first four
      bytes are set to zero.
    <p>
      Bytes 4 to 7 of each free-list trunk page contain the number of
      references to free-list leaf pages (page numbers) stored on the
      free-list trunk page. Each leaf page on the free-list is referenced
      by exactly one trunk page.
    <p>
      The remaining space on a free-list trunk page is used to store the
      page numbers of free-list leaf pages as 4 byte big-endian integers. 
      Each free-list trunk page contains up to:
    <pre>
        <i>max-leaf-pointers</i> := (<i>usable-size</i> - 8) / 4
</pre>
    <p>
      pointers, where <i>usable-size</i> is defined as the <a class=defnlink href="#glossary_Page_size">page-size</a> in bytes
      less the number of unused bytes left at the end of every page (as read
      from byte offset 20 of the <a class=defnlink href="#glossary_Database_header">database header</a>).

      
      <center>
      <a name="figure_freelistpage"></a>
      <img src="images/fileformat/freelistpage.gif">
      <p><i>Figure 12 - Free List Trunk Page Format</i>
      </center>
  
    <p>
      All trunk pages in the free-list except for the first contain the 
      maximum possible number of references to leaf pages. <span class=todo>Is this actually true in an auto-vacuum capable database? Later: No, not even nearly true. It is a false statement.</span> The page number
      of the first page in the linked list of free-list trunk pages is 
      stored as a 4-byte big-endian unsigned integer at offset 32 of the
      <a class=defnlink href="#glossary_Database_header">database header</a> (section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>).

          <p class=req id=H31240><span>All <i>free pages</i> in a <i>well-formed <a class=defnlink href="#glossary_Database_file">database file</a></i> are part of
the database <i>free page list</i>.</span></p>
          <p class=req id=H31250><span>Each free page is either a <i>free list trunk</i> page or a
<i>free list leaf</i> page.</span></p>
          <p class=req id=H31260><span>All <i>free list trunk</i> pages are linked together into a singly
linked list. The first 4 bytes of each page in the linked list
contains the page number of the next page in the list, formatted
as an unsigned big-endian integer. The first 4 bytes of the last
page in the linked list are set to 0x00.</span></p>
          <p class=req id=H31270><span>The second 4 bytes of each <i>free list trunk</i> page contains
the number of </i>free list leaf</i> page numbers stored on the free list
trunk page, formatted as an unsigned big-endian integer.</span></p>
          <p class=req id=H31280><span>Beginning at byte offset 8 of each <i>free list trunk</i> page are
<i>N</i> page numbers, each formatted as a 4-byte unsigned big-endian
integers, where <i>N</i> is the value described in requirement <a class=reqlink href=#H31270>H31270</a>.</span></p>
          <p class=req id=H31290><span>All page numbers stored on all <i>free list trunk</i> pages refer to
database pages that are <i>free list leaves</i>.</span></p>
          <p class=req id=H31300><span>The page number of each <i>free list leaf</i> page in a well-formed
<a class=defnlink href="#glossary_Database_file">database file</a> appears exactly once within the set of pages numbers
stored on <i>free list trunk</i> pages.</span></p>

    <p>The following statements govern the two 4-byte big-endian integers
       associated with the <i>free page list</i> structure in the <a class=defnlink href="#glossary_Database_header">database
       header</a>.

          <p class=req id=H31310><span>The total number of pages in the free list, including all <i>free list
trunk</i> and <i>free list leaf</i> pages, is stored as a 4-byte unsigned
big-endian integer at offset 36 of the <a class=defnlink href="#glossary_Database_file">database file</a> header.</span></p>
          <p class=req id=H31320><span>The page number of the first page in the linked list of <i>free list
trunk</i> pages is stored as a 4-byte big-endian unsigned integer at
offset 32 of the <a class=defnlink href="#glossary_Database_file">database file</a> header. If there are no <i>free list
trunk</i> pages in the <a class=defnlink href="#glossary_Database_file">database file</a>, then the value stored at
offset 32 of the <a class=defnlink href="#glossary_Database_file">database file</a> header is 0.</span></p>
  

  <h2 id="pointer_map_pages">2.5 Pointer Map Pages</h2>

    <p>
      Pointer map pages are only present in auto-vacuum capable databases.
      A database is an auto-vacuum capable database if the value stored 
      at byte offset 52 of the file-header is non-zero.
    <p>
      If they are present, the pointer-map pages together form a lookup 
      table that can be used to determine the type and "parent page" of
      any page in the database, given its page number. The lookup table
      classifies pages into the following categories:
    <table style="margin:1em auto;width:80%;border-spacing:0">
      <tr style="text-align:left"><th>Page Type <th>Byte Value <th>Description
      <tr style="text-align:left;background-color:#DDDDDD"><td style="white-space:nowrap">B-Tree Root Page<td>0x01
          <td>The page is the root page of a table or index B-Tree structure.
              There is no parent page number in this case, the value stored
              in the pointer map lookup table is always zero.
      <tr style="text-align:left"><td>Free Page<td>0x02
          <td>The page is part of the free page list (section
              <cite><a href="#free_page_list" title="The Free Page List">2.4</a></cite>). There is no parent page in this
              case, zero is stored in the lookup table instead of a parent
              page number.
      <tr style="text-align:left;background-color:#DDDDDD"><td>Overflow type 1<td>0x03
          <td>The page is the first page in an overflow chain. The parent
              page is the B-Tree page containing the B-Tree cell to which
              the overflow chain belongs.
      <tr style="text-align:left"><td style="white-space:nowrap">Overflow type 2<td>0x04
          <td>The page is part of an overflow chain, but is not the first
              page in that chain. The parent page is the previous page in
              the overflow chain linked-list.
      <tr style="text-align:left;background-color:#DDDDDD"><td>B-Tree Page<td>0x05
          <td>The page is part of a table or index B-Tree structure, and is 
              not an overflow page or root page. The parent page is the page
              containing the parent tree node in the B-Tree structure.
    </table>
    <p>
      Pointer map pages themselves do not appear in the pointer-map lookup
      table. Page 1 does not appear in the pointer-map lookup table either.

    
      <center>
      <a name="figure_pointermapentry"></a>
      <img src="images/fileformat/pointermapentry.gif">
      <p><i>Figure 13 - Pointer Map Entry Format</i>
      </center>
  
    <p>
      Each pointer-map lookup table entry consumes 5 bytes of space. 
      The first byte of each entry indicates the page type, according to the 
      key described in the table above. The following 4 bytes store the 
      parent page number as a big-endian unsigned integer. This format is
      depicted in figure <cite><a href="#figure_pointermapentry" title="Pointer Map Entry Format">13</a></cite>. Each 
      pointer-map page may therefore contain:
    <pre>
        <i>num-entries</i> := <i>usable-size</i> / 5
</pre>
    <p>
      entries, where <i>usable-size</i> is defined as the <a class=defnlink href="#glossary_Page_size">page-size</a> in bytes
      less the number of unused bytes left at the end of every page (as read
      from byte offset 20 of the <a class=defnlink href="#glossary_Database_header">database header</a>).
    <p>
      Assuming the database is auto-vacuum capable, page 2 is always a 
      pointer map page. It contains the pointer map lookup table entries for
      pages 3 through (2 + <i>num-entries</i>), inclusive. The first 5 bytes
      of page 2 contain the pointer map lookup table entry for page 3. Bytes
      5 through 9, inclusive, contain the pointer map lookup table entry
      for page 4, and so on.
    <p>
      The next pointer map page in the database is page number (3 +
      <i>num-entries</i>), which contains the pointer map entries for pages
      (4 + <i>num-entries</i>) through (3 + 2 * <i>num-entries</i>) 
      inclusive. In general, for any value of <i>n</i> greater than zero, 
      the following page is a pointer-map page that contains lookup 
      table entries for the <i>num-entries</i> pages that follow it in the
      <a class=defnlink href="#glossary_Database_file">database file</a>:
    <pre>
        <i>pointer-map-page-number</i> := 2 + <i>n</i> * <i>num-entries</i>
</pre>


          <p class=req id=H31330><span>Non auto-vacuum databases do not contain pointer map pages.</span></p>
          <p class=req id=H31340><span>In an auto-vacuum <a class=defnlink href="#glossary_Database_file">database file</a>, every <i>(num-entries + 1)</i>th
page beginning with page 2 is designated a pointer-map page, where
<i>num-entries</i> is calculated as:
<code>
<i>num-entries</i> := <i>database-usable-<a class=defnlink href="#glossary_Page_size">page-size</a></i> / 5
</code></span></p>
          <p class=req id=H31350><span>In an auto-vacuum <a class=defnlink href="#glossary_Database_file">database file</a>, each pointer-map page contains
a pointer map entry for each of the <i>num-entries</i> (defined by
<a class=reqlink href=#H31340>H31340</a>) pages that follow it, if they exist.</span></p>
          <p class=req id=H31360><span>Each pointer-map page entry consists of a 1-byte page type and a
4-byte page parent number, 5 bytes in total.</span></p>
          <p class=req id=H31370><span>Pointer-map entries are packed into the pointer-map page in order,
starting at offset 0. The entry associated with the database
page that immediately follows the pointer-map page is located at
offset 0. The entry for the following page at offset 5 etc.</span></p>

    <p>
      The following requirements govern the content of pointer-map entries.

          <p class=req id=H31380><span>For each page except page 1 in an auto-vacuum <a class=defnlink href="#glossary_Database_file">database file</a> that is
the root page of a B-Tree structure, the page type of the
corresponding pointer-map entry is set to the value 0x01 and the
parent page number is zero.</span></p>
          <p class=req id=H31390><span>For each page that is a part of an auto-vacuum <a class=defnlink href="#glossary_Database_file">database file</a> free-list,
the page type of the corresponding pointer-map entry is set to the
value 0x02 and the parent page number is zero.</span></p>
          <p class=req id=H31400><span>For each page in a well-formed auto-vacuum database that is the first
page in an overflow chain, the page type of the corresponding
pointer-map entry is set to 0x03 and the parent page number field
is set to the page number of the B-Tree page that contains the start
of the B-Tree cell stored in the overflow-chain.</span></p>
          <p class=req id=H31410><span>For each page that is the second or a subsequent page in an overflow
chain, the page type of the corresponding pointer-map entry is set to
0x04 and the parent page number field is set to the page number of the
preceding page in the overflow chain.</span></p>
          <p class=req id=H31420><span>For each page that is not a root page but is a part of a B-Tree tree
structure (not part of an overflow chain), the page type of the
corresponding pointer-map entry is set to the value 0x05 and the parent
page number field is set to the page number of the parent node in the
B-Tree structure.</span></p>

<h1 id="file_system_usage">3 <a class=defnlink href="#glossary_Database_File-System_Representation">Database File-System Representation</a></h1>


    <p>
      The previous section, section <cite><a href="#database_file_format" title="Database Image Format Details">2</a></cite> 
      describes the format of an SQLite <a class=defnlink href="#glossary_Database_image">database image</a>. A <a class=defnlink href="#glossary_Database_image">database
      image</a> is the serialized form of a logical SQLite database. Normally,
      a <a class=defnlink href="#glossary_Database_image">database image</a> is stored within the file-system in a single
      file, a <a class=defnlink href="#glossary_Database_file">database file</a>. In this case no other data is stored
      within the <a class=defnlink href="#glossary_Database_file">database file</a>. The first byte of the <i><a class=defnlink href="#glossary_Database_file">database
      file</a></i> is the first byte of the <a class=defnlink href="#glossary_Database_image">database image</a>, and the last 
      byte of the <a class=defnlink href="#glossary_Database_file">database file</a> is the last byte of the <i><a class=defnlink href="#glossary_Database_image">database 
      image</a></i>. For this reason, SQLite is often described as a "single-file 
      database system". However, an SQLite <a class=defnlink href="#glossary_Database_image">database image</a> is not always 
      stored in a single file within the file-system. It is also possible 
      for it to be distributed between the <a class=defnlink href="#glossary_Database_file">database file</a> and a <a class=defnlink href="#glossary_Journal_file">journal file</a>. A
      third file, a <i>master-<a class=defnlink href="#glossary_Journal_file">journal file</a></i> may also be part of the
      file-system representation. Although a <i>master-<a class=defnlink href="#glossary_Journal_file">journal file</a></i> never
      contains any part of the <i><a class=defnlink href="#glossary_Database_image">database image</a></i>, it can contain meta-data
      that helps determine which parts of the <a class=defnlink href="#glossary_Database_image">database image</a> are stored within
      the <a class=defnlink href="#glossary_Database_file">database file</a>, and which parts are stored within the <a class=defnlink href="#glossary_Journal_file">journal file</a>.

    <p>
      In other words, the file-system representation of an SQLite database
      consists of the following:

    <ul>
      <li> <p>A main <b><a class=defnlink href="#glossary_Database_file">database file</a></b>. The <a class=defnlink href="#glossary_Database_file">database file</a> is
           always present. It may be zero bytes in size, but it is always
           present.
           
      <li> <p>Optionally, a <b><a class=defnlink href="#glossary_Journal_file">journal file</a></b>. If present, the <i><a class=defnlink href="#glossary_Journal_file">journal
           file</a></i> is stored in the same file-system directory as the
           <a class=defnlink href="#glossary_Database_file">database file</a>. The name of the <a class=defnlink href="#glossary_Journal_file">journal file</a> is the
           same as that of the <a class=defnlink href="#glossary_Database_file">database file</a> with the string "-journal"
           appended to it.

      <li> <p>Optionally, a <b>master-<a class=defnlink href="#glossary_Journal_file">journal file</a></b> may also be part of the
           file-system representation of a <a class=defnlink href="#glossary_Database_image">database image</a>. A master-<a class=defnlink href="#glossary_Journal_file">journal
           file</a> may only be part of the representation if the <a class=defnlink href="#glossary_Journal_file">journal file</a> 
           is present. A <i>master-<a class=defnlink href="#glossary_Journal_file">journal file</a></i> may be located anywhere
           within the file-system and may take any name. If present, the
           <i>master-journal</i> is identified by the <i><a class=defnlink href="#glossary_Master_Journal_Pointer">master-journal
           pointer</a></i> stored in the <a class=defnlink href="#glossary_Journal_file">journal file</a> (see section
           <cite><a href="#master_journal_ptr" title="Master Journal Pointer">3.1.1.3</a></cite> for details).
    </ul>

    <p>
      Usually, a <a class=defnlink href="#glossary_Database_image">database image</a> is stored entirely within the <a class=defnlink href="#glossary_Database_file">database
      file</a>. Other configurations, where the <a class=defnlink href="#glossary_Database_image">database image</a> data
      is distributed between the <a class=defnlink href="#glossary_Database_file">database file</a> and its <a class=defnlink href="#glossary_Journal_file">journal
      file</a>, are used as interim states when modifying the contents of
      the <a class=defnlink href="#glossary_Database_image">database image</a> to commit a database transaction. In practice,
      a database reader only encounters such a configuration if a previous
      attempt to modify the <a class=defnlink href="#glossary_Database_image">database image</a> on disk was interrupted by an
      application, OS or power failure. The most practical approach (and
      that taken by SQLite) is to extract the subset of the <a class=defnlink href="#glossary_Database_image">database image</a>
      currently stored within the <a class=defnlink href="#glossary_Journal_file">journal file</a> and write it into the <a class=defnlink href="#glossary_Database_file">database
      file</a>, thus restoring the system to a state where the <a class=defnlink href="#glossary_Database_file">database file</a>
      contains the entire <a class=defnlink href="#glossary_Database_image">database image</a>. Other SQLite documentation, and 
      the comments in the SQLite source code, identify this process as <i>hot 
      journal rollback</i>. Instead of focusing on the <i>hot journal
      rollback</i> process, this document describes how journal and
      master-<a class=defnlink href="#glossary_Journal_file">journal files</a> must be interpreted in order to extract the 
      current <a class=defnlink href="#glossary_Database_image">database image</a> from the file-system representation in the
      general case.

    <p>
      Sub-section <cite><a href="#journal_file_formats" title="Journal File Formats">3.1</a></cite> describes the formats 
      used by <i>journal</i> and <i>master-journal</i> files.

    <p>
      Sub-section <cite><a href="#reading_from_files" title="Reading an SQLite Database">3.2</a></cite> contains a precise 
      description of the various ways a <a class=defnlink href="#glossary_Database_image">database image</a> may be
      distributed between the <a class=defnlink href="#glossary_Database_file">database file</a> and <a class=defnlink href="#glossary_Journal_file">journal file</a>, 
      and the rules that must be followed to extract it. In other words, a 
      description of how SQLite or compatible software reads the <a class=defnlink href="#glossary_Database_image">database 
      image</a> from the file-system.

<h2 id="journal_file_formats">3.1 <a class=defnlink href="#glossary_Journal_file">Journal File</a> Formats</h2>


  <p>
    The following sub-sections describe the formats used by SQLite <a class=defnlink href="#glossary_Journal_file">journal
    files</a> (section <cite><a href="#journal_file_format" title="Journal File Details">3.1.1</a></cite>) and master <a class=defnlink href="#glossary_Journal_file">journal files</a>
    (section <cite><a href="#masterjournal_file_format" title="Master-Journal File Details">3.1.2</a></cite>).


<h3 id="journal_file_format">3.1.1 <a class=defnlink href="#glossary_Journal_file">Journal File</a> Details</h3>


    <p>
      This section describes the format used by an SQLite <a class=defnlink href="#glossary_Journal_file">journal file</a>.

    <p>
      A <a class=defnlink href="#glossary_Journal_file">journal file</a> consists of one or more <a class=defnlink href="#glossary_Journal_Section">journal sections</a>, optionally
      followed by a <a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a> field. The first <a class=defnlink href="#glossary_Journal_Section">journal section</a>
      starts at the beginning of the <a class=defnlink href="#glossary_Journal_file">journal file</a>. There is no limit to the
      number of <a class=defnlink href="#glossary_Journal_Section">journal sections</a> that may be present in a single <a class=defnlink href="#glossary_Journal_file">journal file</a>.

    <p>
      Each <a class=defnlink href="#glossary_Journal_Section">journal section</a> consists of a <a class=defnlink href="#glossary_Journal_Header">journal header</a> immediately followed
      by zero or more <a class=defnlink href="#glossary_Journal_Record">journal records</a>. The format of <a class=defnlink href="#glossary_Journal_Header">journal header</a> and <a class=defnlink href="#glossary_Journal_Record">journal
      records</a> are described in sections <cite><a href="#journal_header_format" title="Journal Header Format">3.1.1.1</a></cite> and
      <cite><a href="#journal_record_format" title="Journal Record Format">3.1.1.2</a></cite> respectively. One of the numeric fields 
      stored in a <a class=defnlink href="#glossary_Journal_Header">journal header</a> is the <a class=defnlink href="#glossary_Sector_size">sector size</a> field. Each <a class=defnlink href="#glossary_Journal_Section">journal section</a> 
      in a <a class=defnlink href="#glossary_Journal_file">journal file</a> must be an integer multiple of the <a class=defnlink href="#glossary_Sector_size">sector size</a> stored
      in the first <a class=defnlink href="#glossary_Journal_Header">journal header</a> of the <a class=defnlink href="#glossary_Journal_file">journal file</a> (the value of the <a class=defnlink href="#glossary_Sector_size">sector
      size</a> field in the second and subsequent <a class=defnlink href="#glossary_Journal_Header">journal headers</a> is not used). If
      the sum of the sizes of the <a class=defnlink href="#glossary_Journal_Header">journal header</a> and <a class=defnlink href="#glossary_Journal_Record">journal records</a> in a <a class=defnlink href="#glossary_Journal_Section">journal
      section</a> is not an integer multiple of the <a class=defnlink href="#glossary_Sector_size">sector size</a>, then up to 
      (<a class=defnlink href="#glossary_Sector_size">sector-size</a> - 1) bytes of unused space (padding) follow the end of the
      last <a class=defnlink href="#glossary_Journal_Record">journal record</a> to make up the required length.

    <p>
      Figure <cite><a href="#figure_journal_format" title="Journal File Format">14</a></cite> illustrates a <a class=defnlink href="#glossary_Journal_file">journal file</a> that 
      contains <i>N</i> <a class=defnlink href="#glossary_Journal_Section">journal sections</a> and a <a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a>. The first
      <a class=defnlink href="#glossary_Journal_Section">journal section</a> in the file is depicted as containing <i>M</i> <a class=defnlink href="#glossary_Journal_Record">journal
      records</a>.

    
      <center>
      <a name="figure_journal_format"></a>
      <img src="images/fileformat/journal_format.gif">
      <p><i>Figure 14 - <a class=defnlink href="#glossary_Journal_file">Journal File</a> Format</i>
      </center>
  

    <p>
      The following requirements define a well-formed <a class=defnlink href="#glossary_Journal_Section">journal section</a>. This concept
      is used in section <cite><a href="#reading_from_files" title="Reading an SQLite Database">3.2</a></cite>. 

        <p class=req id=H32210><span>A buffer shall be considered to contain a well-formed <a class=defnlink href="#glossary_Journal_Section">journal section</a> 
if it is not excluded from this category by requirements <a class=reqlink href=#H32220>H32220</a>, <a class=reqlink href=#H32230>H32230</a> or
<a class=reqlink href=#H32240>H32240</a>.</span></p>
        <p class=req id=H32220><span>A buffer shall only be considered to contain a well-formed <a class=defnlink href="#glossary_Journal_Section">journal section</a> 
if the first 28 bytes of it contain a well-formed <a class=defnlink href="#glossary_Journal_Header">journal header</a>.</span></p>
        <p class=req id=H32230><span>A buffer shall only be considered to contain a well-formed <a class=defnlink href="#glossary_Journal_Section">journal section</a> 
if, beginning at byte offset <a class=defnlink href="#glossary_Sector_size">sector-size</a>, it contains a sequence of 
record-count well-formed <a class=defnlink href="#glossary_Journal_Record">journal records</a>. In this case <a class=defnlink href="#glossary_Sector_size">sector-size</a> and
record-count are the integer values stored in the <a class=defnlink href="#glossary_Sector_size">sector size</a> and record
count fields of the <a class=defnlink href="#glossary_Journal_Section">journal section</a>'s <a class=defnlink href="#glossary_Journal_Header">journal header</a>.</span></p>
        <p class=req id=H32240><span>A buffer shall only be considered to contain a well-formed <a class=defnlink href="#glossary_Journal_Section">journal section</a> 
if it is an integer multiple of <a class=defnlink href="#glossary_Sector_size">sector-size</a> bytes in size, where <a class=defnlink href="#glossary_Sector_size">sector-size</a> 
is the value stored in the <a class=defnlink href="#glossary_Sector_size">sector size</a> field of the <a class=defnlink href="#glossary_Journal_Section">journal section</a>'s <a class=defnlink href="#glossary_Journal_Header">journal
header</a>.</span></p>

    <p>
      Note that a <a class=defnlink href="#glossary_Journal_Section">journal section</a> that is not strictly speaking a well-formed
      <a class=defnlink href="#glossary_Journal_Section">journal section</a> often contains important data. For example, many <a class=defnlink href="#glossary_Journal_file">journal 
      files</a> created by SQLite that consist of a single <a class=defnlink href="#glossary_Journal_Section">journal section</a> and no
      <a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a> contain a <a class=defnlink href="#glossary_Journal_Section">journal section</a> that is not well-formed
      according to requirement <a class=reqlink href=#H32240>H32240</a>. See section <cite><a href="#reading_from_files" title="Reading an SQLite Database">3.2</a></cite> 
      for details on when well-formedness is an important property of <a class=defnlink href="#glossary_Journal_Section">journal
      sections</a> and when it is not.

    <h4 id="journal_header_format">3.1.1.1 <a class=defnlink href="#glossary_Journal_Header">Journal Header</a> Format</h4>


    <p>
      A <a class=defnlink href="#glossary_Journal_Header">journal header</a> is <a class=defnlink href="#glossary_Sector_size">sector-size</a> bytes in size, where <a class=defnlink href="#glossary_Sector_size">sector-size</a> is the 
      value stored as a 32-bit big-endian unsigned integer at byte offset 20 of
      the first <a class=defnlink href="#glossary_Journal_Header">journal header</a> that occurs in the <a class=defnlink href="#glossary_Journal_file">journal file</a>. The <a class=defnlink href="#glossary_Sector_size">sector-size</a>
      must be an integer power of two greater than or equal to 512. The
      <a class=defnlink href="#glossary_Sector_size">sector-size</a> is chosen by the process that creates the <a class=defnlink href="#glossary_Journal_file">journal file</a> based
      on the considerations described in section <cite>writing_to_files</cite>.
      Only the first 28 bytes of the <a class=defnlink href="#glossary_Journal_Header">journal header</a> are used, the remainder may
      contain garbage data. The first 28 bytes of each <i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i>
      consists of an eight byte block set to a well-known value, followed by
      five big-endian 32-bit unsigned integer fields.
     
    
      <center>
      <a name="figure_journal_header"></a>
      <img src="images/fileformat/journal_header.gif">
      <p><i>Figure 15 - <a class=defnlink href="#glossary_Journal_Header">Journal Header</a> Format</i>
      </center>
  

    <p>
      Figure <cite><a href="#figure_journal_header" title="Journal Header Format">15</a></cite> graphically depicts the layout
      of a <i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i>. The individual fields are described in
      the following table. The offsets in the 'byte offset' column of the
      table are relative to the start of the <i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i>.

    <table style="margin:1em auto;width:80%;border-spacing:0">
      <tr style="text-align:left"><th>Byte offset<th>Size in bytes<th width=100%>Description
      <tr style="text-align:left;background-color:#DDDDDD"><td>0<td>8<td>The <b>journal magic</b> field always contains a
                        well-known 8-byte string value used to identify SQLite
                        <a class=defnlink href="#glossary_Journal_file">journal files</a>. The well-known sequence of byte values
                        is:
                        <pre>0xd9 0xd5 0x05 0xf9 0x20 0xa1 0x63 0xd7</pre>
      <tr style="text-align:left"><td>8<td>4<td>This field, the <b>record count</b>, is set to the
                        number of <i><a class=defnlink href="#glossary_Journal_Record">journal records</a></i> that follow this
                        <i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i> in the <a class=defnlink href="#glossary_Journal_file">journal file</a>.
      <tr style="text-align:left;background-color:#DDDDDD"><td>12<td>4<td>The <b>checksum initializer</b> field is set to a 
                         pseudo-random value. It is used as part of the
                         algorithm to calculate the checksum for all <i><a class=defnlink href="#glossary_Journal_Record">journal
                         records</a></i> that follow this <i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i>.
      <tr style="text-align:left"><td>16<td>4<td>This field, the <b>database page count</b>, is set
                         to the number of pages that the <a class=defnlink href="#glossary_Database_file">database file</a>
                         contained before any modifications associated with
                         <i>write transaction</i> are applied.
      <tr style="text-align:left;background-color:#DDDDDD"><td>20<td>4<td>This field, the <b><a class=defnlink href="#glossary_Sector_size">sector size</a></b>, is set to the
                         <i><a class=defnlink href="#glossary_Sector_size">sector size</a></i> of the device on which the 
                         <a class=defnlink href="#glossary_Journal_file">journal file</a> was created, in bytes. This value
                         is required when reading the <a class=defnlink href="#glossary_Journal_file">journal file</a> to determine
                         the size of each <i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i>.
      <tr style="text-align:left"><td>24<td>4<td>The <b><a class=defnlink href="#glossary_Page_size">page size</a></b> field contains the database <a class=defnlink href="#glossary_Page_size">page
                         size</a> used by the corresponding <a class=defnlink href="#glossary_Database_file">database file</a>
                         when the <a class=defnlink href="#glossary_Journal_file">journal file</a> was created, in bytes.
    </table>

    <p>
      Because a <a class=defnlink href="#glossary_Journal_Header">journal header</a> always occurs at the start of a <a class=defnlink href="#glossary_Journal_Section">journal 
      section</a>, and because the size of each <a class=defnlink href="#glossary_Journal_Section">journal section</a> is always a
      multiple of <a class=defnlink href="#glossary_Sector_size">sector-size</a> bytes, <a class=defnlink href="#glossary_Journal_Header">journal headers</a> are always positioned
      in the file such that they start at a <a class=defnlink href="#glossary_Sector_size">sector-size</a> aligned offset.

    <p>
      The following requirements define a "well-formed <a class=defnlink href="#glossary_Journal_Header">journal header</a>". This
      concept is used in the following sections. A well-formed <a class=defnlink href="#glossary_Journal_Header">journal header</a>
      is defined as a blob of 28 bytes for which the journal magic field is set
      correctly and for which both the <a class=defnlink href="#glossary_Page_size">page size</a> and <a class=defnlink href="#glossary_Sector_size">sector size</a> fields are set
      to power of two values greater than 512. Because there are no
      restrictions on the values that may be stored in the record count,
      checksum initializer or database page count fields, they do not enter
      into the definition of a well-formed <a class=defnlink href="#glossary_Journal_Header">journal header</a>.

      <p class=req id=H32090><span>A buffer of 28 bytes shall be considered a well-formed <a class=defnlink href="#glossary_Journal_Header">journal 
header</a> if it is not excluded by requirements <a class=reqlink href=#H32180>H32180</a>, <a class=reqlink href=#H32190>H32190</a> or <a class=reqlink href=#H32200>H32200</a>.</span></p>
      <p class=req id=H32180><span>A buffer of 28 bytes shall only be considered a well-formed <a class=defnlink href="#glossary_Journal_Header">journal
header</a> if the first eight bytes of the buffer contain the values 0xd9, 
0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, and 0xd7, respectively.</span></p>
      <p class=req id=H32190><span>A buffer of 28 bytes shall only be considered a well-formed <a class=defnlink href="#glossary_Journal_Header">journal
header</a> if the value stored in the <a class=defnlink href="#glossary_Sector_size">sector size</a> field (the 4-byte big-endian 
unsigned integer at offset 20 of the buffer) contains a value that
is an integer power of two greater than 512.</span></p>
      <p class=req id=H32200><span>A buffer of 28 bytes shall only be considered a well-formed <a class=defnlink href="#glossary_Journal_Header">journal
header</a> if the value stored in the <a class=defnlink href="#glossary_Page_size">page size</a> field (the 4-byte big-endian 
unsigned integer at offset 24 of the buffer) contains a value that
is an integer power of two greater than 512.</span></p>

  <h4 id="journal_record_format">3.1.1.2 <a class=defnlink href="#glossary_Journal_Record">Journal Record</a> Format</h4>


    <p>
    Each <i><a class=defnlink href="#glossary_Journal_Record">journal record</a></i> contains the data for a single database page,
    a page number identifying the page, and a checksum value used to help
    detect <a class=defnlink href="#glossary_Journal_file">journal file</a> corruption.

    
      <center>
      <a name="figure_journal_record"></a>
      <img src="images/fileformat/journal_record.gif">
      <p><i>Figure 16 - <a class=defnlink href="#glossary_Journal_Record">Journal Record</a> Format</i>
      </center>
  

    <p>
      A <i><a class=defnlink href="#glossary_Journal_Record">journal record</a></i>, depicted graphically by figure
      <cite><a href="#figure_journal_record" title="Journal Record Format">16</a></cite>, contains three fields, as described
      in the following table. Byte offsets are relative to the start of the
      <i><a class=defnlink href="#glossary_Journal_Record">journal record</a></i>.

    <table style="margin:1em auto;width:80%;border-spacing:0">
      <tr style="text-align:left"><th>Byte offset<th>Size in bytes<th width=100%>Description
      <tr style="text-align:left;background-color:#DDDDDD"><td>0<td>4<td>The page number of the database page associated with
                        this <i><a class=defnlink href="#glossary_Journal_Record">journal record</a></i>, stored as a 4 byte
                        big-endian unsigned integer.
      <tr style="text-align:left"><td>4<td><i><a class=defnlink href="#glossary_Page_size">page-size</a><td>
                        This field contains the original data for the page,
                        exactly as it appeared in the <a class=defnlink href="#glossary_Database_file">database file</a> before the
                        <i>write transaction</i> began.
      <tr style="text-align:left;background-color:#DDDDDD"><td style="white-space: nowrap">4 + <i><a class=defnlink href="#glossary_Page_size">page-size</a></i><td>4<td>
                        This field contains a checksum value, calculated based
                        on the contents of the journaled database page data
                        (the previous field) and the values stored in the
                        <i>checksum initializer</i> field of the preceding
                        <i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i>.
    </table>

    <p>
      The checksum value stored in each <a class=defnlink href="#glossary_Journal_Record">journal record</a> is calculated based
      on the contents of the page data field of the record and the value
      stored in the checksum initializer field of the <a class=defnlink href="#glossary_Journal_Header">journal header</a> that
      occurs immediately before the <a class=defnlink href="#glossary_Journal_Record">journal record</a>. The checksum initializer
      field is interpreted as a 32-bit unsigned integer. To this value is
      added the value stored in every 200th byte of the page data field,
      interpreted as an 8-bit unsigned integer, beginning with the byte
      at offset (<a class=defnlink href="#glossary_Page_size">page-size</a> % 200). The sum is accumulated in a 32-bit 
      unsigned integer. Overflow is handled by wrapping around to zero.

      <div style="padding: 0 1ex; float:right">
      <div style="padding: 0 1ex; border:1px solid black">
      Example Checksum Calculation:
      <pre>
  Sum of values:
       0xFFFFFFE1 + 
       0x00000023 +
       0x00000032 +
       0x0000009E +
       0x00000062 +
       0x0000001F
      -----------
      0x100000155

  Truncated to 32-bits: 
       0x00000155</pre>
      </div></div>

    <p>
      For example, if the <a class=defnlink href="#glossary_Page_size">page-size</a> is 1024 bytes, then the offsets within
      the page of the bytes added to the checksum initializer value are
      24, 224, 424, 624 and 824 (the first byte of the page is offset 0, the
      last byte is offset 1023). If the values of the bytes at these offsets
      are 0x23, 0x32, 0x9E, 0x62 and 0x1F, and the value of the checksum
      initializer field is 0xFFFFFFE1, then the value stored in the checksum
      field of the <a class=defnlink href="#glossary_Journal_Record">journal record</a> is 0x00000155.


    <p>
      The set of <i><a class=defnlink href="#glossary_Journal_Record">journal records</a></i> that follow a <i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i>
      in a <a class=defnlink href="#glossary_Journal_file">journal file</a> are packed tightly together. There are no alignment 
      requirements for <i><a class=defnlink href="#glossary_Journal_Record">journal records</a></i>.

      <p class=req id=H32100><span>A buffer of (8 + <a class=defnlink href="#glossary_Page_size">page size</a>) bytes shall be considered a well-formed <a class=defnlink href="#glossary_Journal_Record">journal 
record</a> if it is not excluded by requirements <a class=reqlink href=#H32110>H32110</a> or <a class=reqlink href=#H32120>H32120</a>.</span></p>
      <p class=req id=H32110><span>A <a class=defnlink href="#glossary_Journal_Record">journal record</a> shall only be considered to be well-formed if the page number
field contains a value other than zero and the locking-page number, calculated
using the <a class=defnlink href="#glossary_Page_size">page size</a> found in the first <a class=defnlink href="#glossary_Journal_Header">journal header</a> of the <a class=defnlink href="#glossary_Journal_file">journal file</a> that
contains the <a class=defnlink href="#glossary_Journal_Record">journal record</a>.</span></p>
      <p class=req id=H32120><span>A <a class=defnlink href="#glossary_Journal_Record">journal record</a> shall only be considered to be well-formed if the checksum 
field contains a value equal to the sum of the value stored in the 
checksum-initializer field of the <a class=defnlink href="#glossary_Journal_Header">journal header</a> that precedes the record
and the value stored in every 200th byte of the page data field, interpreted
as an 8-bit unsigned integer), starting with byte offset (<a class=defnlink href="#glossary_Page_size">page-size</a> % 200) and
ending with the byte at byte offset (<a class=defnlink href="#glossary_Page_size">page-size</a> - 200).</span></p>


  <h4 id="master_journal_ptr">3.1.1.3 <a class=defnlink href="#glossary_Master_Journal_Pointer">Master Journal Pointer</a></h4>


    <p>
      If present, a <a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a> occurs at the end of a <a class=defnlink href="#glossary_Journal_file">journal file</a>.
      There may or may not be unused space between the end of the final <a class=defnlink href="#glossary_Journal_Section">journal 
      section</a> and the start of the <a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a>.

    <p>
      A <i><a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a></i> contains the full path of a 
      <i>master <a class=defnlink href="#glossary_Journal_file">journal-file</a></i> along with a check-sum and some well-known values 
      that allow the <i><a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a></i> to be unambiguously distinguished 
      from a <a class=defnlink href="#glossary_Journal_Record">journal record</a> or <a class=defnlink href="#glossary_Journal_Header">journal header</a>.

    
      <center>
      <a name="figure_master_journal_ptr"></a>
      <img src="images/fileformat/master_journal_ptr.gif">
      <p><i>Figure 17 - <a class=defnlink href="#glossary_Master_Journal_Pointer">Master Journal Pointer</a> Format</i>
      </center>
  

    <p>
      A <i><a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a></i>, depicted graphically by figure
      <cite><a href="#figure_master_journal_ptr" title="Master Journal Pointer Format">17</a></cite>, contains five fields, as 
      described in the following table. Byte offsets are relative to the 
      start of the <i><a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a></i>.

    <table style="margin:1em auto;width:80%;border-spacing:0">
      <tr style="text-align:left"><th>Byte offset<th>Size in bytes<th width=100%>Description
      <tr style="text-align:left;background-color:#DDDDDD"><td>0<td>4<td>This field, the <b>locking page number</b>, is always
               set to the page number of the database <i>locking page</i>
               stored as a 4-byte big-endian integer. The <i>locking page</i>
               is the page that begins at byte offset 2<sup>30</sup> of the
               <a class=defnlink href="#glossary_Database_file">database file</a>. Even if the <a class=defnlink href="#glossary_Database_file">database file</a> is large enough to
               contain the <i>locking page</i>, the <i>locking page</i> is
               never used to store any data and so the first four bytes of of a
               valid <i><a class=defnlink href="#glossary_Journal_Record">journal record</a></i> will never contain this value.

      <tr style="text-align:left"><td>4<td><i>name-length</i><td>
               The <b>master journal name</b> field contains the name of the
               master <a class=defnlink href="#glossary_Journal_file">journal file</a>, encoded as a utf-8 string. There is no
               nul-terminator appended to the string.
      <tr style="text-align:left;background-color:#DDDDDD"><td>4 + <i>name-length</i><td><i>4<td>
               The <b>name-length</b> field contains the length of the 
               previous field in bytes, formatted as a 4-byte big-endian 
               unsigned integer.
      <tr style="text-align:left"><td>8 + <i>name-length</i><td><i>4<td>
               The <b>checksum</b> field contains a checksum value stored as
               a 4-byte big-endian signed integer. The checksum value is
               calculated as the sum of the bytes that make up the <i>
               master journal name</i> field, interpreting each byte as
               an 8-bit signed integer.
      <tr style="text-align:left;background-color:#DDDDDD"><td style="white-space: nowrap">12 + <i>name-length</i><td><i>8<td>
               Finally, the <b>journal magic</b> field always contains a
               well-known 8-byte string value; the same value stored in the
               first 8 bytes of a <i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i>. The well-known
               sequence of bytes is:
                 <pre>0xd9 0xd5 0x05 0xf9 0x20 0xa1 0x63 0xd7</pre>
    </table>

      <p class=req id=H32140><span>A buffer shall only be considered to be a well-formed <a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a>
if the final eight bytes of the buffer contain the values 0xd9, 0xd5, 0x05, 
0xf9, 0x20, 0xa1, 0x63, and 0xd7, respectively.</span></p>
      <p class=req id=H32150><span>A buffer shall only be considered to be a well-formed <a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a>
if the size of the buffer in bytes is equal to the value stored as a 4-byte 
big-endian unsigned integer starting 16 bytes before the end of the buffer.</span></p>
      <p class=req id=H32160><span>A buffer shall only be considered to be a well-formed <a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a>
if the first four bytes of the buffer, interpreted as a big-endian unsigned
integer, contain the page number of the locking page (the value
(1 + 2<sup>30</sup> / <a class=defnlink href="#glossary_Page_size">page-size</a>), where <a class=defnlink href="#glossary_Page_size">page-size</a> is the value stored in
the <a class=defnlink href="#glossary_Page_size">page-size</a> field of the first <a class=defnlink href="#glossary_Journal_Header">journal header</a> of the <a class=defnlink href="#glossary_Journal_file">journal file</a>).</span></p>
      <p class=req id=H32170><span>A buffer shall only be considered to be a well-formed <a class=defnlink href="#glossary_Master_Journal_Pointer">master journal pointer</a>
if the value stored as a 4-byte big-endian integer starting 12 bytes before
the end of the buffer is equal to the sum of all bytes, each interpreted
as an 8-bit unsigned integer, starting at offset 4 of the buffer and continuing
until offset (buffer-size - 16) (the 17th last byte of the buffer).</span></p>

<h3 id="masterjournal_file_format">3.1.2 Master-<a class=defnlink href="#glossary_Journal_file">Journal File</a> Details</h3>


  <p>
    A <i>master-<a class=defnlink href="#glossary_Journal_file">journal file</a></i> contains the full paths to two or more
    <i><a class=defnlink href="#glossary_Journal_file">journal files</a></i>, each encoded using UTF-8 encoding and terminated
    by a single nul character (byte value 0x00). There is no padding 
    between the journal paths, each UTF-8 encoded path begins immediately
    after the nul character that terminates the previous one.

  <p class=todo>
    Note that the contents of a master-journal is not really all that
    important, and is not required at all to read the <a class=defnlink href="#glossary_Database_image">database image</a>. 
    Used for cleanup only.

<h2 id="reading_from_files">3.2 Reading an SQLite Database</h2>


  <p>
    As described in section <cite><a href="#pages_and_page_types" title="Pages and Page Types">2.2.2</a></cite> of this document,
    an SQLite <a class=defnlink href="#glossary_Database_image">database image</a> is a set of contiguously numbered fixed size 
    pages. The numbering starts at 1, not 0. Page 1 contains the 
    <a class=defnlink href="#glossary_Database_header">database header</a> and the root page of the <i>schema table</i>, 
    and all other pages within the <a class=defnlink href="#glossary_Database_image">database image</a> are somehow referenced
    by number, either directly or indirectly, from page 1, either directly 
    or indirectly. In order to be able to read the <a class=defnlink href="#glossary_Database_image">database image</a> from within
    the file-system, a database reader needs to be able to ascertain:

  <ol>
    <li> The <i><a class=defnlink href="#glossary_Page_size">page-size</a></i> used by the <a class=defnlink href="#glossary_Database_image">database image</a>,
    <li> The number of pages in the <a class=defnlink href="#glossary_Database_image">database image</a>, and
    <li> The content of each database page.
  </ol>

  <p>
    Usually, the <a class=defnlink href="#glossary_Database_image">database image</a> is simply the contents of the <a class=defnlink href="#glossary_Database_file">database file</a>. 
    In this case, reading the <a class=defnlink href="#glossary_Database_image">database image</a> is straightforward. The
    <a class=defnlink href="#glossary_Page_size">page-size</a> used by the <a class=defnlink href="#glossary_Database_image">database image</a> can be read from the 2-byte
    big-endian integer field stored at byte offset 16 of
    the <a class=defnlink href="#glossary_Database_file">database file</a> (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>). The number of
    pages in the <a class=defnlink href="#glossary_Database_image">database image</a> can be determined by querying the size of
    the <a class=defnlink href="#glossary_Database_file">database file</a> in bytes and then dividing by the <i><a class=defnlink href="#glossary_Page_size">page-size</a></i>.
    Reading the contents of a <i>database page</i> is a simple matter of 
    reading a block of <i><a class=defnlink href="#glossary_Page_size">page-size</a></i> bytes from an offset calculated from
    the page-number of the required page:
    <pre>
        <i>offset</i> := (<i>page-number</i> - 1) * <a class=defnlink href="#glossary_Page_size">page-size</a>
</pre>
    
  <p>
    However, if there is a valid <a class=defnlink href="#glossary_Journal_file">journal file</a> corresponding to the 
    <a class=defnlink href="#glossary_Database_file">database file</a> present within the file-system then the situation 
    is more complicated. The file-system is considered to contain a valid 
    <a class=defnlink href="#glossary_Journal_file">journal file</a> if each of the following conditions are met:

  <ul>
    <li> A <a class=defnlink href="#glossary_Journal_file">journal file</a> is present in the file system, and
    <li> the <a class=defnlink href="#glossary_Journal_file">journal file</a> either does not end with a well-formed 
         <i><a class=defnlink href="#glossary_Master_Journal_Pointer">master-journal pointer</a></i> (see section 
         <cite><a href="#master_journal_ptr" title="Master Journal Pointer">3.1.1.3</a></cite>) or the <i>master-<a class=defnlink href="#glossary_Journal_file">journal file</a></i> 
         referred to by the <i><a class=defnlink href="#glossary_Master_Journal_Pointer">master-journal pointer</a></i> is present in
         the file-system, and
    <li> the first 28 bytes of the <a class=defnlink href="#glossary_Journal_file">journal file</a> contain a 
         well-formed <i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i> (see section
         <cite><a href="#journal_header_format" title="Journal Header Format">3.1.1.1</a></cite>).  
  </ul>

  <p>
    If the file system contains a valid <a class=defnlink href="#glossary_Journal_file">journal file</a>, then the
    <i><a class=defnlink href="#glossary_Page_size">page-size</a></i> used by and the number of pages in the <i><a class=defnlink href="#glossary_Database_image">database
    image</a></i> are stored in the first <i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i> of the 
    <a class=defnlink href="#glossary_Journal_file">journal file</a>. Specifically, the <a class=defnlink href="#glossary_Page_size">page-size</a> is stored as a 4-byte
    big-endian unsigned integer at byte offset 24 of the <a class=defnlink href="#glossary_Journal_file">journal file</a>, and the
    number of pages in the <a class=defnlink href="#glossary_Database_image">database image</a> is stored as a 4-byte big-endian
    unsigned integer at byte offset of 16 of the same file.
    
  <p>
    The current data for each page of the <a class=defnlink href="#glossary_Database_image">database image</a> may be stored 
    within the <a class=defnlink href="#glossary_Database_file">database file</a> at a file offset based on its page number as 
    it normally is, or the current version of the data may be stored 
    somewhere within the <a class=defnlink href="#glossary_Journal_file">journal file</a>. For each page within the <a class=defnlink href="#glossary_Database_image">database 
    image</a>, if the <a class=defnlink href="#glossary_Journal_file">journal file</a> contains a valid <a class=defnlink href="#glossary_Journal_Record">journal record</a> for the
    corresponding page-number, then the current content of the <a class=defnlink href="#glossary_Database_image">database 
    image</a> page is the blob of data stored in the page data field of the
    <a class=defnlink href="#glossary_Journal_Record">journal record</a>. If the <a class=defnlink href="#glossary_Journal_file">journal file</a> does not contain a valid <a class=defnlink href="#glossary_Journal_Record">journal
    record</a> for a page, then the current content of the <a class=defnlink href="#glossary_Database_image">database image</a> page
    is the blob of data currently stored in the corresponding region of
    the <a class=defnlink href="#glossary_Database_file">database file</a>.

  <p>
    Not all <a class=defnlink href="#glossary_Journal_Record">journal records</a> within a <a class=defnlink href="#glossary_Journal_file">journal file</a> are valid. A <a class=defnlink href="#glossary_Journal_Record">journal 
    record</a> is said to be valid if:

  <ul>
    <li> The <a class=defnlink href="#glossary_Journal_file">journal file</a> that contains the <a class=defnlink href="#glossary_Journal_Record">journal record</a> is a valid 
         <a class=defnlink href="#glossary_Journal_file">journal file</a>, and
    <li> all <a class=defnlink href="#glossary_Journal_Section">journal sections</a> that occur before the <a class=defnlink href="#glossary_Journal_Section">journal section</a> 
         containing the <a class=defnlink href="#glossary_Journal_Record">journal record</a> are well-formed, and
    <li> the <a class=defnlink href="#glossary_Journal_Section">journal section</a> that contains the <a class=defnlink href="#glossary_Journal_Record">journal record</a> begins with 
         a well-formed <a class=defnlink href="#glossary_Journal_Header">journal header</a>, and
    <li> the <a class=defnlink href="#glossary_Journal_Record">journal record</a> itself and all <a class=defnlink href="#glossary_Journal_Record">journal records</a> that occur before
         it in the same <a class=defnlink href="#glossary_Journal_Section">journal section</a> are well-formed.
  </ul>

  <p>
    Note that it is not necessary for a <a class=defnlink href="#glossary_Journal_Record">journal record</a> to be part of a
    well-formed <a class=defnlink href="#glossary_Journal_Section">journal section</a> to be considered valid.

  <p>
    Figure <cite><a href="#figure_filesystem1" title="Two ways to store the same database image">18</a></cite> illustrates two distinct ways
    to store a <a class=defnlink href="#glossary_Database_image">database image</a> within the file system. In this example, the
    <a class=defnlink href="#glossary_Database_image">database image</a> consists of 4 pages of <i><a class=defnlink href="#glossary_Page_size">page-size</a></i> bytes each. The
    content of each of the 4 pages is designated A, B, C and D, respectively.
    Representation 1 uses only the <a class=defnlink href="#glossary_Database_file">database file</a>. In this case the entire
    <a class=defnlink href="#glossary_Database_image">database image</a> is stored in the <a class=defnlink href="#glossary_Database_file">database file</a>.

  <p>
    In representation 2 of figure <cite><a href="#figure_filesystem1" title="Two ways to store the same database image">18</a></cite>, the current
    <a class=defnlink href="#glossary_Database_image">database images</a> is stored using both the <a class=defnlink href="#glossary_Journal_file">journal file</a> and the <a class=defnlink href="#glossary_Database_file">database 
    file</a>. The size and <a class=defnlink href="#glossary_Page_size">page-size</a> of the <a class=defnlink href="#glossary_Database_image">database image</a> are both stored in
    the first (in this case only) <a class=defnlink href="#glossary_Journal_Header">journal header</a> in the <a class=defnlink href="#glossary_Journal_file">journal file</a>. 
    Following the <a class=defnlink href="#glossary_Journal_Header">journal header</a> are two valid <a class=defnlink href="#glossary_Journal_Record">journal records</a>. These contain
    the data for pages 3 and 4 of the <a class=defnlink href="#glossary_Database_image">database image</a>. Because there are no
    valid <a class=defnlink href="#glossary_Journal_Record">journal records</a> for pages 1 and 2 of the <a class=defnlink href="#glossary_Database_image">database image</a>, the content
    for each of these is stored in the <a class=defnlink href="#glossary_Database_file">database file</a>. Even though the contents
    of the file-system is quite different in representation 2 as in
    representation 1, the stored <a class=defnlink href="#glossary_Database_image">database image</a> is the same in each case: 4
    pages of <a class=defnlink href="#glossary_Page_size">page-size</a> bytes each, content A, B, C and D respectively.

    
      <center>
      <a name="figure_filesystem1"></a>
      <img src="images/fileformat/filesystem1.gif">
      <p><i>Figure 18 - Two ways to store the same <a class=defnlink href="#glossary_Database_image">database image</a></i>
      </center>
  

  <p class=todo>
    The requirements that follow talk about "well-formed" <a class=defnlink href="#glossary_Journal_Section">journal sections</a>,
    records and <a class=defnlink href="#glossary_Master_Journal_Pointer">master-journal-pointers</a>. There should be some kind of reference
    back to the definitions of these things. Either in the requirements
    themselves (refer to other requirements by number) or in the surrounding
    text (point to document sections). Or, better, both.

  <p>
    These requirements describe the way a database reader must determine
    whether or not there is a valid <a class=defnlink href="#glossary_Journal_file">journal file</a> within the 
    file-system.

    <p class=req id=H32000><span>If a <a class=defnlink href="#glossary_Journal_file">journal file</a> contains a well-formed <a class=defnlink href="#glossary_Master_Journal_Pointer">master-journal pointer</a> and the 
named master-<a class=defnlink href="#glossary_Journal_file">journal file</a> does not exist then the <a class=defnlink href="#glossary_Journal_file">journal file</a> shall be 
considered invalid.</span></p>
    <p class=req id=H32010><span>If the first 28 bytes of a <i><a class=defnlink href="#glossary_Journal_file">journal file</a></i> do not contain a well-formed
<i><a class=defnlink href="#glossary_Journal_Header">journal header</a></i>, then the <i><a class=defnlink href="#glossary_Journal_file">journal file</a></i> shall be considered
invalid.</span></p>
    <p class=req id=H32020><span>If the <a class=defnlink href="#glossary_Journal_file">journal file</a> exists within the file-system and neither <a class=reqlink href=#H32000>H32000</a> 
, <a class=reqlink href=#H32010>H32010</a> nor <a class=reqlink href=#H33080>H33080</a> apply, then the <a class=defnlink href="#glossary_Journal_file">journal file</a> shall be considered valid.</span></p>

  <p>
    If there is a valid <a class=defnlink href="#glossary_Journal_file">journal file</a> within the file-system, the 
    following requirements govern how a reader should determine the set
    of valid <i><a class=defnlink href="#glossary_Journal_Record">journal records</a></i> that it contains.

    <p class=req id=H32250><span>A <a class=defnlink href="#glossary_Journal_Record">journal record</a> found within a valid <a class=defnlink href="#glossary_Journal_file">journal file</a> shall be considered a valid
<a class=defnlink href="#glossary_Journal_Record">journal record</a> if it is not excluded from this category by requirement <a class=reqlink href=#H32260>H32260</a>,
<a class=reqlink href=#H32270>H32270</a> or <a class=reqlink href=#H32280>H32280</a>.</span></p>
    <p class=req id=H32260><span>A <a class=defnlink href="#glossary_Journal_Record">journal record</a> shall only be considered a valid <a class=defnlink href="#glossary_Journal_Record">journal record</a> if it and any
other <a class=defnlink href="#glossary_Journal_Record">journal records</a> that occur before it within the same <a class=defnlink href="#glossary_Journal_Section">journal section</a> are
well-formed.</span></p>
    <p class=req id=H32270><span>A <a class=defnlink href="#glossary_Journal_Record">journal record</a> shall only be considered a valid <a class=defnlink href="#glossary_Journal_Record">journal record</a> if the <a class=defnlink href="#glossary_Journal_Section">journal
section</a> to which it belongs begins with a well-formed <a class=defnlink href="#glossary_Journal_Header">journal header</a>.</span></p>
    <p class=req id=H32280><span>A <a class=defnlink href="#glossary_Journal_Record">journal record</a> shall only be considered a valid <a class=defnlink href="#glossary_Journal_Record">journal record</a> if all <a class=defnlink href="#glossary_Journal_Section">journal
sections</a> that occur before the <a class=defnlink href="#glossary_Journal_Section">journal section</a> containing the <a class=defnlink href="#glossary_Journal_Record">journal record</a>
are well-formed <a class=defnlink href="#glossary_Journal_Section">journal sections</a>.</span></p>

  <p>
    The following requirements dictate the way in which database
    <i><a class=defnlink href="#glossary_Page_size">page-size</a></i> and the number of pages in the <a class=defnlink href="#glossary_Database_image">database image</a>
    should be determined by the reader.

    <p class=req id=H32030><span>If there exists a valid <i><a class=defnlink href="#glossary_Journal_file">journal file</a></i> in the file-system, then the
database <i><a class=defnlink href="#glossary_Page_size">page-size</a></i> in bytes used to interpret the <i><a class=defnlink href="#glossary_Database_image">database image</a></i>
shall be the value stored as a 4-byte big-endian unsigned integer at byte
offset 24 of the <i><a class=defnlink href="#glossary_Journal_file">journal file</a></i>.</span></p>
    <p class=req id=H32040><span>If there exists a valid <i><a class=defnlink href="#glossary_Journal_file">journal file</a></i> in the file-system, then the
number of pages in the <i><a class=defnlink href="#glossary_Database_image">database image</a></i> shall be the value stored as 
a 4-byte big-endian unsigned integer at byte offset 24 of the 
<i><a class=defnlink href="#glossary_Journal_file">journal file</a></i>.</span></p>
    <p class=req id=H32050><span>If there is no valid <i><a class=defnlink href="#glossary_Journal_file">journal file</a></i> in the file-system, then the
database <i><a class=defnlink href="#glossary_Page_size">page-size</a></i> in bytes used to interpret the <i><a class=defnlink href="#glossary_Database_image">database image</a></i>
shall be the value stored as a 2-byte big-endian unsigned integer at byte
offset 16 of the <i><a class=defnlink href="#glossary_Database_file">database file</a></i>.</span></p>
    <p class=req id=H32060><span>If there is no valid <i><a class=defnlink href="#glossary_Journal_file">journal file</a></i> in the file-system, then the
number of pages in the <i><a class=defnlink href="#glossary_Database_image">database image</a></i> shall be calculated by dividing
the size of the <i><a class=defnlink href="#glossary_Database_file">database file</a></i> in bytes by the database <i><a class=defnlink href="#glossary_Page_size">page-size</a></i>.</span></p>

  <p>
    The following requirements dictate the way in which the data for each
    page of the <a class=defnlink href="#glossary_Database_image">database image</a> can be located within the file-system
    by a database reader.

    <p class=req id=H32070><span>If there exists a valid <i><a class=defnlink href="#glossary_Journal_file">journal file</a></i> in the file-system, then the
contents of each page of the <i><a class=defnlink href="#glossary_Database_image">database image</a></i> for which there is a valid
<i><a class=defnlink href="#glossary_Journal_Record">journal record</a></i> in the <i><a class=defnlink href="#glossary_Journal_file">journal file</a></i> shall be read from the
corresponding <a class=defnlink href="#glossary_Journal_Record">journal record</a>.</span></p>
    <p class=req id=H32080><span>The contents of all <i><a class=defnlink href="#glossary_Database_image">database image</a></i> pages for which there is no valid
<i><a class=defnlink href="#glossary_Journal_Record">journal record</a></i> shall be read from the <a class=defnlink href="#glossary_Database_file">database file</a>.</span></p>

<h1 id="interoperability_requirements">4 SQLite Interoperability Requirements</h1>


  <p>
    This section contains requirements that further constrains the behaviour
    of software that accesses (reads and/or writes) SQLite databases stored
    within the file-system. These requirements need only be implemented by
    systems that access databases while other clients may also be doing so.
    More specifically, they need only be implemented by software operating
    within a system where one or more of the database clients writes to the
    database. If the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a> remains constant
    at all times, or if there is only ever a single database client for each
    database within the system, the requirements in this section can be 
    ignored.

  <p>
    The requirements in this section fall into three categories:

  <ul>
    <li> <p><b>Database Writer Requirements</b>. Section <cite><a href="#writing_database" title="Writing to an SQLite Database File">4.1</a></cite>
         contains notes on and requirements that must be observed by software 
	 systems that update an existing SQLite <a class=defnlink href="#glossary_Database_image">database image</a> within the file-system.

    <li> <p><b>Locking Requirements</b>. Section <cite><a href="#locking_protocol" title="SQLite Locking Protocol">4.2</a></cite>
         contains a description of the file-system locks that must be obtained
         on the <a class=defnlink href="#glossary_Database_file">database file</a>, and how locks placed by other database clients 
         should be interpreted.

    <li> <p><b>Header Cookie Requirements</b>. An SQLite <a class=defnlink href="#glossary_Database_image">database image</a> header 
         (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>) contains two "cookie" values
         that must sometimes be incremented when the <a class=defnlink href="#glossary_Database_image">database image</a> stored in
         the file-system is updated. Section 
         <cite><a href="#database_header_cookies_protocol" title="SQLite Database Header Cookie Protocol">4.3</a></cite> contains requirements
         identifying exactly when the cookie values must be incremented, and
         how they can be used by a database client to determine if cached
         data is valid or not.
  </ul> 

  <h2 id="writing_database">4.1 Writing to an SQLite <a class=defnlink href="#glossary_Database_file">Database File</a></h2>


  <p>
    When writing to an SQLite database, the database representation on disk
    must be modified to reflect the new, modified, <a class=defnlink href="#glossary_Database_image">database image</a>. Exactly
    how this is done in terms of raw IO operations depends on the 
    characteristics of the file-system in which the database is stored and
    the degree to which the application is required to handle failures within
    the system. A failure may be an application crash, an operating system
    crash, a power failure or other unexpected event that terminates 
    processing. For example, SQLite itself runs in several different modes
    with various levels of guarantees on how failures are handled as follows:

  <ul>
    <li> <b>In-memory journal mode</b> (PRAGMA journal_mode=memory). In this
      mode any failure may cause <a class=defnlink href="#glossary_Database_file">database file</a>-system corruption, including an
      application crash or unexpected exit.
    <li> <b>Non-synchronous mode</b> (PRAGMA synchronous=off). In this mode 
      an application crash or unexpected exit may not cause database 
      corruption, however an operating system crash or power failure may.
    <li> <b>Synchronous mode</b> (PRAGMA synchronous=full). In this mode 
      neither an application crash, operating system crash or power failure 
      may cause <a class=defnlink href="#glossary_Database_file">database file</a>-system corruption.
  </ul>

  <p>
    If a process attempts to modify a database so as to replace <a class=defnlink href="#glossary_Database_image">database
    image</a> A with <a class=defnlink href="#glossary_Database_image">database image</a> B and a failure occurs while doing so, 
    then following recovery the file-system must contain a <a class=defnlink href="#glossary_Database_image">database image</a> 
    equivalent to A or B. Otherwise, the <a class=defnlink href="#glossary_Database_file">database file</a>-system is considered 
    corrupt.
    
  <p>
    Two <a class=defnlink href="#glossary_Database_image">database images</a> are considered to be equivalent if each of the 
    following are true:

    <ul>
      <li> <p> The two <a class=defnlink href="#glossary_Database_image">database images</a> have the same <a class=defnlink href="#glossary_Page_size">page-size</a>.
      <li> <p> The two <a class=defnlink href="#glossary_Database_image">database images</a> have the same number of pages.
      <li> <p> The content of each page in the first <a class=defnlink href="#glossary_Database_image">database image</a> that is not
               a free-list leaf page is identical to the corresponding page in
               the second <a class=defnlink href="#glossary_Database_image">database image</a>.
    </ul>

  <p> 
    The exception for free-list leaf pages (see section
    <cite><a href="#free_page_list" title="The Free Page List">2.4</a></cite>) in the third bullet point above is made
    because free-list leaf pages contain no valid data and are never read
    by SQLite database readers. Since the blob of data stored on such a
    page is never read for any purpose, two <a class=defnlink href="#glossary_Database_image">database images</a> may have a
    different blob stored on a free-list leaf page and still be considered
    equivalent. This concept can sometimes be exploited to more efficiently
    update an SQLite <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a>.

    <p class=req id=H32290><span>Two <a class=defnlink href="#glossary_Database_image">database images</a> shall be considered to be equivalent if they (a) have the
same <a class=defnlink href="#glossary_Page_size">page size</a>, (b) contain the same number of pages and (c) the content of
each page of the first <a class=defnlink href="#glossary_Database_image">database image</a> that is not a free-list leaf page is
the same as the content of the corresponding page in the second <a class=defnlink href="#glossary_Database_image">database image</a>.</span></p>

  <p>
    The following requirement constrains the way in which a <a class=defnlink href="#glossary_Database_File-System_Representation">database 
    file-system representation</a> may be updated. In many ways, it is
    equivalent to "do not corrupt the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a>
    under those conditions where the file-system should not be corrupted".
    The definition of "handled failure" depends on the mode that SQLite
    is running in (or on the requirements of the external system accessing
    the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a>).

    <p class=req id=H32300><span>If, while writing to an SQLite <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a> in 
order to replace <a class=defnlink href="#glossary_Database_image">database image</a> A with <a class=defnlink href="#glossary_Database_image">database image</a> B, a failure that
should be handled gracefully occurs, then following recovery the <a class=defnlink href="#glossary_Database_File-System_Representation">database
file-system representation</a> shall contain a <a class=defnlink href="#glossary_Database_image">database image</a> equivalent to
either A or B.</span></p>

  <p>
    The following two sections, <cite><a href="#rollback_journal_method" title="The Rollback-Journal Method">4.1.1</a></cite>
    and <cite><a href="#atomic_write_method" title="The Atomic-Write Method">4.1.2</a></cite>, are somewhat advisory in nature.
    They contain descriptions of two different methods used by SQLite to
    modify a <a class=defnlink href="#glossary_Database_image">database image</a> within a <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a> in
    accordance with the above requirements. They are not the only methods
    that can be used. So long as the above requirements (and
    those in sections <cite><a href="#locking_protocol" title="SQLite Locking Protocol">4.2</a></cite> and 
    <cite><a href="#database_header_cookies_protocol" title="SQLite Database Header Cookie Protocol">4.3</a></cite>) are honoured, any method may
    be used by an SQLite database writer to update the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system
    representation</a>. Sections <cite><a href="#rollback_journal_method" title="The Rollback-Journal Method">4.1.1</a></cite> and 
    <cite><a href="#atomic_write_method" title="The Atomic-Write Method">4.1.2</a></cite> do not contain formal requirements. Formal
    requirements governing the way in which SQLite safely updates <a class=defnlink href="#glossary_Database_File-System_Representation">database
    file-system representations</a> may be found in <span class=todo>Not available yet!</span>.
    An informal description is available in <cite><a href="#atomic_commit_page" title="">[3]</a></cite>.

  <h3 id="rollback_journal_method">4.1.1 The Rollback-Journal Method</h3>


    <p>
      This section describes the method usually used by SQLite to update a <a class=defnlink href="#glossary_Database_image">database 
      image</a> within a <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a>. This is one way
      to modify a <a class=defnlink href="#glossary_Database_image">database image</a> in accordance with the requirements in the
      parent and other sections. When overwriting <a class=defnlink href="#glossary_Database_image">database image</a> A with <a class=defnlink href="#glossary_Database_image">database 
      image</a> B using this method, assuming that to begin with <a class=defnlink href="#glossary_Database_image">database image</a> A is 
      entirely contained within the <a class=defnlink href="#glossary_Database_file">database file</a> and that the <a class=defnlink href="#glossary_Page_size">page-size</a> of
      <a class=defnlink href="#glossary_Database_image">database image</a> B is the same as that of <a class=defnlink href="#glossary_Database_image">database image</a> A, the following 
      steps are taken:

    <ol>
      <li> <p>The start of the <a class=defnlink href="#glossary_Journal_file">journal file</a> is populated with data that is not
           a valid <a class=defnlink href="#glossary_Journal_Header">journal header</a>.
      <li> <p>For each page in <a class=defnlink href="#glossary_Database_image">database image</a> A that is not a free-list leaf 
           page and either does not exist in <a class=defnlink href="#glossary_Database_image">database image</a> B or exists but
           is populated with different content, a record is written to the
           <a class=defnlink href="#glossary_Journal_file">journal file</a>. The record contains a copy of the original <a class=defnlink href="#glossary_Database_image">database
           image</a> A page.
      <li> <p>The start of the <a class=defnlink href="#glossary_Journal_file">journal file</a> is populated with a valid <a class=defnlink href="#glossary_Journal_Header">journal
           header</a>. The page-count field of the <a class=defnlink href="#glossary_Journal_Header">journal header</a> is set to the
           number of pages in <a class=defnlink href="#glossary_Database_image">database image</a> A. The record-count is set to the 
           number of records written to the <a class=defnlink href="#glossary_Journal_file">journal file</a> in step 2.
      <li> <p>The content of each page of <a class=defnlink href="#glossary_Database_image">database image</a> B that is either not
           present or populated differently in <a class=defnlink href="#glossary_Database_image">database image</a> A is copied
           into the <a class=defnlink href="#glossary_Database_file">database file</a>. If <a class=defnlink href="#glossary_Database_image">database image</a> B is smaller than <a class=defnlink href="#glossary_Database_image">database
           image</a> A, the <a class=defnlink href="#glossary_Database_file">database file</a> is truncated to the size required by
           <a class=defnlink href="#glossary_Database_image">database image</a> B.
      <li> <p>One of several file-system operations that cause the <a class=defnlink href="#glossary_Journal_file">journal file</a>
           to become invalid is performed. For example:
           <ul>
             <li>The <a class=defnlink href="#glossary_Journal_file">journal file</a> is deleted from the file-system, or
             <li>The <a class=defnlink href="#glossary_Journal_file">journal file</a> is truncated to zero bytes in size, or
             <li>Some or all of the first 8 bytes of the <a class=defnlink href="#glossary_Journal_file">journal file</a> are
                 overwritten so that the <a class=defnlink href="#glossary_Journal_file">journal file</a> no longer begins with 
                 a well-formed <a class=defnlink href="#glossary_Journal_Header">journal header</a> (and is therefore not valid).
           </ul>
    </ol>

    <p>
      During steps 1 and 2 of the above procedure, the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system 
      representation</a> clearly contains <a class=defnlink href="#glossary_Database_image">database image</a> A. The <a class=defnlink href="#glossary_Database_file">database file</a>
      itself has not been modified, and the <a class=defnlink href="#glossary_Journal_file">journal file</a> is not valid (since
      it does not begin with a valid <a class=defnlink href="#glossary_Journal_file">journal file</a> header). Following step 3,
      the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a> still contains <a class=defnlink href="#glossary_Database_image">database image</a>
      A. The number of pages in the <a class=defnlink href="#glossary_Database_image">database image</a> and the content of some
      pages now resides in the <a class=defnlink href="#glossary_Journal_file">journal file</a>, but the <a class=defnlink href="#glossary_Database_image">database image</a> remains
      unchanged. During and following step 4, the current <a class=defnlink href="#glossary_Database_image">database image</a> is
      still <a class=defnlink href="#glossary_Database_image">database image</a> A. Although some or all of the pages in the 
      <a class=defnlink href="#glossary_Database_file">database file</a> may have been overwritten or truncated away, a valid 
      <a class=defnlink href="#glossary_Journal_Record">journal records</a> containing the original <a class=defnlink href="#glossary_Database_image">database image</a> A data exists
      for all such pages that were not free-list leaf pages in <a class=defnlink href="#glossary_Database_image">database 
      image</a> A. And although the size of the <a class=defnlink href="#glossary_Database_file">database file</a> may have been
      modified, the size of the current <a class=defnlink href="#glossary_Database_image">database image</a>, <a class=defnlink href="#glossary_Database_image">database image</a> A, 
      is stored in the <a class=defnlink href="#glossary_Journal_Header">journal header</a>.

    <p>
      Once step 5 of the above procedure is performed, the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system
      representation</a> contains <a class=defnlink href="#glossary_Database_image">database image</a> B. The <a class=defnlink href="#glossary_Journal_file">journal file</a> is no longer
      valid, so the <a class=defnlink href="#glossary_Database_image">database image</a> consists of the contents of the <a class=defnlink href="#glossary_Database_file">database
      file</a>, <a class=defnlink href="#glossary_Database_image">database image</a> B.
  <p>
    Figure <cite><a href="#figure_filesystem2" title="Interim file-system state used to atomically overwrite database image ABCD with AEC">19</a></cite> depicts a possible interim state 
    of the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a> used while committing a transaction
    that replaces a four page <a class=defnlink href="#glossary_Database_image">database image</a> with a three page <a class=defnlink href="#glossary_Database_image">database image</a>.
    The contents of the initial <a class=defnlink href="#glossary_Database_image">database image</a> pages are A, B, C and D respectively. 
    The final <a class=defnlink href="#glossary_Database_image">database image</a> content is A, E and C. The interim state depicted
    is that reached at the end of step 4 in the above procedure. In this state, 
    the file-system contains the initial <a class=defnlink href="#glossary_Database_image">database image</a>, ABCD. However, if the 
    <a class=defnlink href="#glossary_Journal_file">journal file</a> were to be somehow invalidated, then the file-system would 
    contain the final <a class=defnlink href="#glossary_Database_image">database image</a>, AEC.

    
      <center>
      <a name="figure_filesystem2"></a>
      <img src="images/fileformat/filesystem2.gif">
      <p><i>Figure 19 - Interim file-system state used to atomically overwrite <a class=defnlink href="#glossary_Database_image">database image</a> ABCD with AEC</i>
      </center>
  

  <p>
    The procedure described above can be onerous to implement, as it requires
    that the data for all modified pages of <a class=defnlink href="#glossary_Database_image">database image</a> B be available
    (presumably in main memory) at the same time, when step 4 is performed.
    For transactions that write to a large number of database pages, this 
    may be undesirable. A solution is to create a <a class=defnlink href="#glossary_Journal_file">journal-file</a> containing
    two or more <a class=defnlink href="#glossary_Journal_Header">journal headers</a>. If, while modifying a <a class=defnlink href="#glossary_Database_image">database image</a> within
    main-memory, a client wishes to reduce the amount of data held in memory,
    it may perform steps 3 and 4 of the above procedure in order to write
    modified content out to the file-system. Once the modified pages have been
    written into the <a class=defnlink href="#glossary_Database_file">database file</a>, the in-memory copies may be discarded.
    The writer process may then continue accumulating changes in memory. When
    it is ready to write these changes out to the file-system, either to free
    up main-memory or because all changes associated with the transaction have
    been prepared, it adds a second (or subsequent) <a class=defnlink href="#glossary_Journal_Header">journal header</a> to the 
    <a class=defnlink href="#glossary_Journal_file">journal file</a>, followed by <a class=defnlink href="#glossary_Journal_Record">journal records</a> containing the original data
    for pages about to be modified. It may then write the changes accumulated
    in-memory to the <a class=defnlink href="#glossary_Database_file">database file</a>, as described in step 4 above.

  <p>
    This technique can also be modified to support atomic modification of 
    multiple databases. In this case the first 4 steps of the procedure outlined
    above are followed for each individual database. Following this a
    master-<a class=defnlink href="#glossary_Journal_file">journal file</a> is created somewhere within the file-system and a
    <a class=defnlink href="#glossary_Master_Journal_Pointer">master-journal pointer</a> added to each individual <a class=defnlink href="#glossary_Journal_file">journal file</a>. Since
    a <a class=defnlink href="#glossary_Journal_file">journal-file</a> that contains a <a class=defnlink href="#glossary_Master_Journal_Pointer">master-journal pointer</a> to a master-<a class=defnlink href="#glossary_Journal_file">journal
    file</a> that does not exist is considered invalid (requirement <a class=reqlink href=#H32000>H32000</a>),
    all <a class=defnlink href="#glossary_Journal_file">journal-files</a> may be simultaneously invalidated by deleting the
    master-<a class=defnlink href="#glossary_Journal_file">journal file</a> from the file-system. This delete operation takes the
    place of step 5 of the procedure as outlined above.

  <h3 id="atomic_write_method">4.1.2 The Atomic-Write Method</h3>


    <p>
      On some systems, SQLite is able to overwrite a single page of the
      <a class=defnlink href="#glossary_Database_file">database file</a> as an atomic operation. If, while updating the page,
      a failure occurs, the system guarantees that following recovery, the 
      page will be found to have been correctly and completely updated or 
      not modified at all. When running in such an environment, if SQLite
      is required to update a <a class=defnlink href="#glossary_Database_image">database image</a> so that only a single page
      is modified, it can do so simply by overwriting the page.

    <p>
      Assuming the database page being updated is not page 1, if requirement 
      <a class=reqlink href=#H33040>H33040</a> requires that the <a class=defnlink href="#glossary_Database_header">database header</a> change counter be updated, then 
      the <a class=defnlink href="#glossary_Database_image">database image</a> modification is no longer confined to a single page.
      In this case it can be split in two: SQLite first atomically updates
      page 1 of the <a class=defnlink href="#glossary_Database_file">database file</a> to increment the <a class=defnlink href="#glossary_Database_header">database header</a> change 
      counter, then updates the page that it is actually required to update
      using a second atomic write operation. If a failure occurs some time
      between the two write operations, following recovery the <a class=defnlink href="#glossary_Database_image">database 
      image</a> may be found to be in its original state except for the value
      of the <a class=defnlink href="#glossary_Database_header">database header</a> change counter <span class=todo>It would be good
      to have some requirement to say that that is Ok. Some modification to
      the definition of equivalent databases perhaps.</span>

<!--

  <p>
    The following requirements require that the <a class=defnlink href="#glossary_Journal_Header">journal header</a> at the start of
    a <a class=defnlink href="#glossary_Journal_file">journal file</a> is set to contain the original database <a class=defnlink href="#glossary_Page_size">page-size</a> and 
    page-count and written to non-volatile storage before the size of the
    <a class=defnlink href="#glossary_Database_file">database file</a> is modified. And that once the size of the <a class=defnlink href="#glossary_Database_file">database file</a> has
    been modified, the <a class=defnlink href="#glossary_Journal_Header">journal header</a> does not become unstable and the <a class=defnlink href="#glossary_Page_size">page-size</a> 
    and page-count values stored therein are not modified until the end of
    the transaction.

       <p class=req id=H32320><span>When using the rollback-journal method to modify the file-system representation
of a <a class=defnlink href="#glossary_Database_image">database image</a>, the database writer shall ensure that before the size of
the <a class=defnlink href="#glossary_Database_file">database file</a> is modified, the first 28 bytes of the <a class=defnlink href="#glossary_Journal_file">journal file</a> contain a
stable valid <a class=defnlink href="#glossary_Journal_Header">journal header</a> with the <a class=defnlink href="#glossary_Page_size">page-size</a> and page-count fields set to
values corresponding to the original <a class=defnlink href="#glossary_Database_image">database image</a>.</span></p>
       <p class=req id=H32330><span>When using the rollback-journal method to modify the file-system representation
of a <a class=defnlink href="#glossary_Database_image">database image</a>, the database writer shall ensure that the first 28 bytes
of the <a class=defnlink href="#glossary_Journal_file">journal file</a> does not become unstable at any point after the size of the 
<a class=defnlink href="#glossary_Database_file">database file</a> is modified until the <a class=defnlink href="#glossary_Journal_file">journal file</a> is invalidated to commit the
transaction.</span></p>

  <p>
    Journal before overwrite:

       <p class=req id=H32340><span>When using the rollback-journal method to modify the file-system representation
of a <a class=defnlink href="#glossary_Database_image">database image</a>, the database writer shall ensure that before any part of
the <a class=defnlink href="#glossary_Database_file">database file</a> that contained a page of the original <a class=defnlink href="#glossary_Database_image">database image</a> that was
not a free-list leaf page is overwritten or made unstable the <a class=defnlink href="#glossary_Journal_file">journal file</a>
contains a valid and stable <a class=defnlink href="#glossary_Journal_Record">journal record</a> containing the original page data.</span></p>
       <p class=req id=H32350><span>When using the rollback-journal method to modify the file-system representation
of a <a class=defnlink href="#glossary_Database_image">database image</a>, the database writer shall ensure that after any part of
the <a class=defnlink href="#glossary_Database_file">database file</a> that contained a page of the original <a class=defnlink href="#glossary_Database_image">database image</a> that was
not a free-list leaf page has been overwritten or made unstable the corresponding
<a class=defnlink href="#glossary_Journal_Record">journal record</a> (see <a class=reqlink href=#H32340>H32340</a>) is not modified or made unstable.</span></p>

  <p>
    Journal before truncate:

       <p class=req id=H32360><span>When using the rollback-journal method to modify the file-system representation
of a <a class=defnlink href="#glossary_Database_image">database image</a>, the database writer shall ensure that before the <a class=defnlink href="#glossary_Database_file">database
file</a> is truncated, the <a class=defnlink href="#glossary_Journal_file">journal file</a> contains stable valid <a class=defnlink href="#glossary_Journal_Record">journal records</a> 
corresponding to all pages of the original <a class=defnlink href="#glossary_Database_image">database image</a> that were part of the
region being discarded by the truncate operation and were not free-list leaf 
pages.</span></p>
       <p class=req id=H32370><span>When using the rollback-journal method to modify the file-system representation
of a <a class=defnlink href="#glossary_Database_image">database image</a>, the database writer shall ensure that after the <a class=defnlink href="#glossary_Database_file">database
file</a> has been truncated the <a class=defnlink href="#glossary_Journal_Record">journal records</a> corresponding to pages from the
original <a class=defnlink href="#glossary_Database_image">database image</a> that were part of the truncated region and were not
free-list leaf pages are not modified or made unstable.</span></p>
      

  h4 "Multiple Database Transactions" multi_db_transactions

  <p>
    SQLite is required 
    to do make all modifications associated with the transaction such that 
    the <a class=defnlink href="#glossary_Database_image">database image</a> is modified atomically. If an application, OS or 
    power failure occurs while SQLite is updating the database, upon recovery 
    the contents of the database must reflect either that all modifications 
    associated with the database transaction were successfully applied, or 
    that none of the modifications were applied and the contents of the 
    database are as they were before the failed attempt to modify the database.

  <p>
    Therefore, when modifying the file-system representation of a <a class=defnlink href="#glossary_Database_image">database
    image</a> so as to commit a transaction that modifies the <a class=defnlink href="#glossary_Database_image">database image</a>
    from state A to state B, it must be ensured that the file-system at
    all times contains a <a class=defnlink href="#glossary_Database_image">database image</a> in either state A or state B. And
    that if an OS or power failure occurs before, during or after any IO
    operation, following recovery the file-system must contain a <a class=defnlink href="#glossary_Database_image">database
    image</a> in either state A or state B.

  <p class=todo>
    Should introduce requirements here - that the file-system be modified
    such that the file is always in state A or state B.

  <p>
    Some operations on a file-system may be considered atomic. For example
    deleting a file, or on some systems writing to a single disk sector.
    However, in general there exists no atomic file-system operation
    that may be used to update an SQLite <a class=defnlink href="#glossary_Database_file">database file</a> with the effects
    of an arbitrary database transaction, which may remove, modify or
    add multiple database rows, tables or indexes. Therefore, a two stage
    approach to writing an SQLite database (or indeed, modifying the logical
    contents of any on-disk database) is required:

  <ol>
    <li> The file-system representation of the database is manipulated to
         a state where a single atomic operation may be used to transform
         the logical contents of the database from its initial state to
         the required final state.
    <li> The required atomic operation is applied.
  </ol>

  <p class=todo>
    The paragraph below is not quite accurate. Each interim state must
    correspond to either state A or state B. Not necessarily state A.
    And the above is not completely general either, for the same reason.

  <p>
    Step 1 of the above must be accomplished such that all interim states
    of the file-system correspond to the logical contents of the database
    as they were before the procedure began. This way, if an application,
    OS or power failure occurs during step 1, upon recovery the database
    contents remain unchanged. It is not possible for such a failure to
    occur "during" step 2, as step 2 consists of a single atomic operation.

  <p>
    SQLite is also required to support atomic database transactions that 
    involve updates to multiple <a class=defnlink href="#glossary_Database_file">database files</a>. If an application, OS or
    power failure occurs while committing the transaction, it is required
    that following recovery either the logical contents of all affected
    databases have been completely updated, or that the contents of each
    of them remains unchanged. Whether or not a transaction involves 
    multiple <a class=defnlink href="#glossary_Database_file">database files</a>, the principle remains the same: the file-system
    must be manipulated into a state whereby a single atomic file-system
    operation can be used to effect all required changes to the logical
    database contents.

  <p>
    The following two sub-sections describe the specific ways in which 
    SQLite achieves this for single and multiple database transactions.

  h4 "Single Database Transactions" single_db_transactions

  <p>
    In order to atomically modify the <a class=defnlink href="#glossary_Database_image">database image</a> stored in the 
    file-system from <a class=defnlink href="#glossary_Database_image">database image</a> A to <a class=defnlink href="#glossary_Database_image">database image</a> B, the file-system must
    first be manipulated to a state where it contains the <a class=defnlink href="#glossary_Database_image">database image</a> A,
    but can by a single atomic operation be modified to contain <a class=defnlink href="#glossary_Database_image">database 
    image</a> B. A file-system state that has the following properties satisfies
    this requirement:

  <ol>
    <li> The <a class=defnlink href="#glossary_Database_file">database file</a> contains <a class=defnlink href="#glossary_Database_image">database image</a> B.
    <li> There exists a valid <a class=defnlink href="#glossary_Journal_file">journal file</a>.
    <li> The first header of the <a class=defnlink href="#glossary_Journal_file">journal file</a> contains the <a class=defnlink href="#glossary_Page_size">page-size</a> and 
         number of pages in <a class=defnlink href="#glossary_Database_image">database image</a> A.
    <li> The <a class=defnlink href="#glossary_Journal_file">journal file</a> contains a valid <a class=defnlink href="#glossary_Journal_Record">journal record</a> for each page of
         of <a class=defnlink href="#glossary_Database_image">database image</a> A that either does not exist in <a class=defnlink href="#glossary_Database_image">database image</a> B
         (because image B is smaller than image A), or does exist but has
         different content in <a class=defnlink href="#glossary_Database_image">database image</a> B than it does in <a class=defnlink href="#glossary_Database_image">database 
         image</a> A.
  </ol>

  <p>
    In this state, the file-system contains <a class=defnlink href="#glossary_Database_image">database image</a> A. However, if the
    <a class=defnlink href="#glossary_Journal_file">journal file</a> is somehow made invalid, then the file-system will then
    contain <a class=defnlink href="#glossary_Database_image">database image</a> B. There are several possibilities for IO 
    operations that will cause the <a class=defnlink href="#glossary_Journal_file">journal file</a> to become invalid, for 
    example:

  <ul>
    <li> Deleting the <a class=defnlink href="#glossary_Journal_file">journal file</a> from the file-system, or
    <li> Truncating the <a class=defnlink href="#glossary_Journal_file">journal file</a> to zero bytes in size, or
    <li> Overwriting some or all of the first 8 bytes in the <a class=defnlink href="#glossary_Journal_file">journal file</a>
         so that the <a class=defnlink href="#glossary_Journal_file">journal file</a> no longer contains a well-formed <a class=defnlink href="#glossary_Journal_Header">journal
         header</a>.
  </ul>


  h4 "Multiple Database Transactions" multi_db_transactions

  <p class=todo>
    Deleting the master-journal is used as the atomic operation.
-->

  <h2 id="locking_protocol">4.2 SQLite Locking Protocol</h2>


    <p>
      An SQLite database client may hold at any time one of four different types 
      of locks on a <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a>. This document does not
      describe how these locks are to be implemented. Possible implementation
      techniques include mapping the four SQLite locks to operating system file
      locks, using an external software module to manage locks, or by creating
      special "lock files" within the file-system. Regardless of how the locks
      are implemented, it is important that all database clients in a system 
      use the same implementation. The following table summarizes the four 
      types of locks used by SQLite:

    <table style="margin:1em auto;width:80%;border-spacing:0">
      <tr style="text-align:left"> <th> Lock type <th> Description <th> Blocks <th> Blocked By
      <tr style="text-align:left;background-color:#DDDDDD"> <td> SHARED    <td> 
          It is only possible to obtain a SHARED lock if no other client is
          holding a PENDING or EXCLUSIVE lock. Holding a SHARED lock prevents
          any other client from obtaining an EXCLUSIVE lock.
          <td> EXCLUSIVE <td> PENDING, EXCLUSIVE

      <tr style="text-align:left"> <td> RESERVED  <td> 
          A RESERVED lock may only be obtained if no other client holds a 
          RESERVED, PENDING or EXCLUSIVE lock on the database. While a
          client holds a RESERVED lock, other clients may obtain new SHARED
          locks, but may not obtain new RESERVED, PENDING or EXCLUSIVE locks.
          <td> RESERVED, PENDING, EXCLUSIVE <td> RESERVED, PENDING, EXCLUSIVE

      <tr style="text-align:left;background-color:#DDDDDD"> <td> PENDING <td>
          It is only possible to obtain a PENDING lock if no other client holds
          a RESERVED, PENDING or EXCLUSIVE lock. While a database client is 
          holding a PENDING lock, no other client may obtain any new lock. 
          <td> All <td> RESERVED, PENDING, EXCLUSIVE

      <tr style="text-align:left"> <td> EXCLUSIVE <td>
          An EXCLUSIVE lock may only be obtained if no other client holds any
          lock on the database. While an EXCLUSIVE lock is held, no other 
          client may obtain any kind of lock on the database.
          <td> All <td> All

    </table>
      
    <p>
      The most important types of locks are SHARED and EXCLUSIVE. Before any 
      part of the <a class=defnlink href="#glossary_Database_file">database file</a> is read, a database client must obtain a SHARED 
      lock or greater.

    <p class=req id=H33000><span>Before reading from a <a class=defnlink href="#glossary_Database_file">database file</a> , a database reader shall establish a 
SHARED or greater lock on the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a>.</span></p>

    <p>
      Before the <a class=defnlink href="#glossary_Database_file">database file</a> may be written to, a database client must
      be holding an EXCLUSIVE lock. Because holding an EXCLUSIVE lock 
      guarantees that no other client is holding a SHARED lock, it also
      guarantees that no other client may be reading from the <a class=defnlink href="#glossary_Database_file">database file</a>
      as it is being written.

    <p class=req id=H33010><span>Before writing to a <a class=defnlink href="#glossary_Database_file">database file</a>, a database writer shall establish
an EXCLUSIVE lock on the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a>.</span></p>

    <p>
      The two requirements above govern reading from and writing to the
      <a class=defnlink href="#glossary_Database_file">database file</a>. In order to write to a <a class=defnlink href="#glossary_Journal_file">journal file</a>, a database client
      must obtain at least a RESERVED lock.

    <p class=req id=H33020><span>Before writing to a <a class=defnlink href="#glossary_Journal_file">journal file</a>, a database writer shall establish
a RESERVED, PENDING or EXCLUSIVE lock on the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system
representation</a>.</span></p>

    <p>
      The requirement above implies that a database writer may write to the
      <a class=defnlink href="#glossary_Journal_file">journal file</a> at the same time as a reader is reading from the <a class=defnlink href="#glossary_Database_file">database
      file</a>. This improves concurrency in environments that feature multiple
      clients, as a database writer may perform part of its IO before locking
      the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a> with an EXCLUSIVE lock. In order
      for this to work though, the following must be true:

    <ul>
      <li> <p>Database readers must recognize that when a writer holds a RESERVED 
           or PENDING lock on the <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a> the
           writer may be manipulating the <a class=defnlink href="#glossary_Journal_file">journal file</a> and as a result it is
           not safe to read.

      <li> <p>Database writers may only obtain a RESERVED or PENDING lock on the
           <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a> when it would be safe for a
           database reader to assume that the contents of the <a class=defnlink href="#glossary_Database_file">database file</a>
           represents the current <a class=defnlink href="#glossary_Database_image">database image</a>.
    </ul>

    <p>
      The following requirements formally restate the above bullet points.

    <p class=req id=H33030><span>Before establishing a RESERVED or PENDING lock on a <a class=defnlink href="#glossary_Database_file">database file</a>, a 
database writer shall ensure that the <a class=defnlink href="#glossary_Database_file">database file</a> contains a valid 
<a class=defnlink href="#glossary_Database_image">database image</a>.</span></p>
    <p class=req id=H33060><span>Before establishing a RESERVED or PENDING lock on a <a class=defnlink href="#glossary_Database_file">database file</a>, a 
database writer shall ensure that any <a class=defnlink href="#glossary_Journal_file">journal file</a> that may be present
is not a valid <a class=defnlink href="#glossary_Journal_file">journal file</a>.</span></p>
    <p class=req id=H33080><span>If another database client holds either a RESERVED or PENDING lock on the
<a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a>, then any <a class=defnlink href="#glossary_Journal_file">journal file</a> that exists within
the file system shall be considered invalid.</span></p>

  <h2 id="database_header_cookies_protocol">4.3 SQLite <a class=defnlink href="#glossary_Database_header">Database Header</a> Cookie Protocol</h2>


    <p>
      While a database reader is holding a SHARED lock on the <a class=defnlink href="#glossary_Database_File-System_Representation">database
      file-system representation</a>, it may freely cache data in main memory
      since there is no way that another client can modify the <a class=defnlink href="#glossary_Database_image">database
      image</a>. However, if a client relinquishes all locks on a <a class=defnlink href="#glossary_Database_File-System_Representation">database
      file-system representation</a> and then re-establishes a SHARED lock
      at some point in the future, any cached data may or may not be
      valid (as the <a class=defnlink href="#glossary_Database_image">database image</a> may have been modified while the client
      was not holding a lock). The requirements in this section dictate
      the way in which database writers must update two fields of the <a class=defnlink href="#glossary_Database_image">database
      image</a> header (the "cookies") in order to enable readers to determine
      when cached data can be safely reused and when it must be discarded.

    <p>
      SQLite clients may cache two types of data from a <a class=defnlink href="#glossary_Database_image">database image</a> in
      main-memory:

    <ul>
      <li> <p>The <b>database schema</b>. In order to access database content,
           the contents of the schema table must be parsed (see section 
           <cite><a href="#schema_table" title="The Schema Table">2.2.3</a></cite>). Since this is a relatively expensive
           process, it is advantageous for clients to cache the parsed 
           representation in memory.

      <li> <p><a class=defnlink href="#glossary_Database_image">Database image</a> <b>page content</b>. Clients may also cache raw
           page content in order to reduce the number of file-system read 
           operations required when reading the <a class=defnlink href="#glossary_Database_image">database image</a>.
    </ul>

    <p>
      Similar mechanisms are used to support cache validation for each class
      of data. If a database writer changes the database schema in any way, it
      is also required to increment the value stored in the database schema
      version field of the <a class=defnlink href="#glossary_Database_image">database image</a> header (see section 
      <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>). This way, when a database reader establishes
      a SHARED lock on a <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a>, it may validate
      any cached schema data by checking if the value of the database schema 
      version field has changed since the data was cached. If the value has not
      changed, then the cached schema data may be retained and reused. 
      Otherwise, if the value of the database schema version field is not the
      same as it was when the schema data was last cached, then the reader
      can deduce that some other database client has modified the database
      schema in some way and it must be reparsed.

    <p>
      Each time a <a class=defnlink href="#glossary_Database_image">database image</a> stored within a <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system 
      representation</a> is modified, the database writer is required to increment
      the value stored in the change counter field of the <a class=defnlink href="#glossary_Database_image">database image</a> header
      (see section <cite><a href="#database_header" title="Database Header">2.2.1</a></cite>). This allows database readers to
      validate any cache of raw <a class=defnlink href="#glossary_Database_image">database image</a> page content that may be present
      when a database reader establishes a SHARED (or other) lock on the 
      <a class=defnlink href="#glossary_Database_File-System_Representation">database file-system representation</a>. If the value stored in the change
      counter field of the <a class=defnlink href="#glossary_Database_image">database image</a> has not changed since the cached
      data was read, then it may be safely reused. Otherwise, if the change
      counter value has changed, then any cached page content data must be
      deemed untrustworthy and discarded.

    <p>
      If a <a class=defnlink href="#glossary_Database_image">database image</a> is modified more than once while a writer is holding
      an EXCLUSIVE lock, then each header value need only be updated once, as
      part of the first image modification that modifies the associated class
      of data. Specifically, the change counter field need only be incremented
      as part of the first image modification that takes place, and the 
      database schema version need only be incremented as part of the first
      modification that includes a schema change. 

    <p class=req id=H33040><span>A database writer shall increment the value of the <a class=defnlink href="#glossary_Database_header">database header</a> change
counter field, a 4-byte big-endian unsigned integer field stored at byte offset 24
of the <a class=defnlink href="#glossary_Database_header">database header</a>, as part of the first <a class=defnlink href="#glossary_Database_image">database image</a> modification 
that it performs after obtaining an EXCLUSIVE lock.</span></p>
    <p class=req id=H33050><span>A database writer shall increment the value of the database schema version 
field, a 4-byte big-endian unsigned integer field stored at byte offset 40
of the <a class=defnlink href="#glossary_Database_header">database header</a>, as part of the first <a class=defnlink href="#glossary_Database_image">database image</a> modification that
includes a schema change that it performs after obtaining an EXCLUSIVE lock.</span></p>
    <p class=req id=H33070><span>If a database writer is required by either <a class=reqlink href=#H33050>H33050</a> or <a class=reqlink href=#H33040>H33040</a> to increment a
<a class=defnlink href="#glossary_Database_header">database header</a> field, and that header field already contains the maximum
value possible (0xFFFFFFFF, or 4294967295 for 32-bit unsigned integer 
fields), "incrementing" the field shall be interpreted to mean setting it to 
zero.</span></p>


<h1 id="section_5">5 References</h1>


  <table id="refs" style="width:auto; margin: 1em 5ex">
  <tr><td style="width:5ex ; vertical-align:top" id="ref_comer_btree">[1]<td>
     Douglas Comer, <u>Ubiquitous B-Tree</u>, ACM Computing Surveys (CSUR),
     v.11 n.2, pages 121-137, June 1979.
  
  <tr><td style="width:5ex ; vertical-align:top" id="ref_knuth_btree">[2]<td>
     Donald E. Knuth, <u>The Art Of Computer Programming, Volume 3:
     "Sorting And Searching"</u>, pages 473-480. Addison-Wesley
     Publishing Company, Reading, Massachusetts.
  
  <tr><td style="width:5ex ; vertical-align:top" id="atomic_commit_page">[3]<td>
    SQLite Online Documentation,<u>How SQLite Implements Atomic Commit</u>,
    <a href="atomiccommit.html">http://www.sqlite.org/atomiccommit.html</a>.
  
  </table>

  


